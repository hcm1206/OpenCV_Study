# 4 OpenCV 주요 기능

## 4.1 카메라와 동영상 파일 다루기

### 4.1.1 VideoCapture 클래스

- **동영상** : 일련의 정지 영상을 압축하여 파일로 저장한 형태
- **프레임(frame)** : 동영상에 저장되어 있는 일련의 정지 영상
- 동영상을 처리하는 작업은 동영상에서 프레임을 추출한 후, 각각의 프레임에 영상 처리 기법을 적용하는 형태로 이루어짐
- 컴퓨터에 연결된 카메라 장치를 사용하는 작업도 카메라로부터 일정 시간 간격으로 정지 영상 프레임을 받아와서 처리하는 형태
- 그러므로 카메라와 동영상 파일을 다루는 작업은 연속적인 프레임 영상을 받아와서 처리한다는 공통점이 있음

---

- OpenCV에서는 VideoCapture라는 하나의 클래스를 이용하여 카메라 또는 동영상 파일로부터 정지 영상 프레임을 받아올 수 있음
- 간략화한 VideoCapture 클래스 정의를 src/ch04_1 프로젝트 파일에 구현 `주석 4-1`
- 실제 VideoCapture 클래스의 멤버 변수는 모두 protected: 모드로 선언되어 있어서 사용자가 직접 접근할 수 없으며, 프로젝트 파일에 구현된 코드에서는 표시를 생략

---

- VideoCapture 클래스에서 동영상 파일을 불러오려면 처음 VideoCapture 객체를 생성할 때 생성자에 동영상 파일 이름을 지정하거나 또는 기본 생성자로 VideoCapture 객체를 생성한 후 VideoCapture::open() 멤버 함수를 호출해야 함
- 이때 사용하는 VideoCapture 생성자와 VideoCapture::open() 멤버 함수 원형은 아래와 같음
  
> ``` C++
> VideoCapture::VideoCapture(const String& filename, int apiPreference = CAP_ANY);
> bool VideoCapture::open(const String& filename, int apiPreference = CAP_ANY);
> ```
> - filename : 동영상 파일 이름
> - apiPreference : 사용할 비디오 캡처 API 백엔드
> - 반환값 : (VideoCapture::open() 함수) 열기가 성공하면 true, 실패하면 false
  
- filename 인자에는 말 그대로 *.avi, *.mpg, *.mp4 등 확장자를 갖는 동영상 파일 이름을 전달
- 현재 프로그램 실행 폴더에 동영상 파일이 있으면 "video.mp4" 형태로 파일 이름만 지정하면 되고, 다른 폴더에 동영상 파일이 있다면 절대 경로 또는 상대 경로를 추가하여 파일 이름을 지정
  - 예를 들어 하드디스크의 C 드라이브 최상위 폴더에 video.mp4 파일이 있다면 "C:\\video.mp4" 형태로 파일 이름을 전달
- 하나의 동영상 파일 대신 일련의 숫자로 구분되는 이름의 정지 영상 파일을 가지고 있고, 이 파일을 차례대로 불러오고 싶을 때에도 VideoCapture 클래스를 사용할 수 있음
  - 예를 들어 img0001.jpg, img0002,jpg, img0003.jpg 등의 이름으로 구성된 다수의 정지 영상 파일이 있을 경우, filename 인자에 "img%04d.jpg"라고 입력하여 일련의 영상 파일을 차례대로 불러올 수 있음
- filename 인자에 "protocol://host.port/script_name?script_params|auth" 형태의 비디오 스트림 URL을 지정하여 인터넷 동영상을 사용할 수도 있음

<br>

- apiPreference 인자에는 동영상을 불러오는 방법을 지정할 수 있음
- apiPreferencd 인자에는 VideoCaptureAPIs 열거형 상수 중 하나를 지정
- 주로 사용되는 VideoCaptureAPIs 열거형 상수 일부와 그 의미를 아래에 표기
- 그러나 대부분의 경우 apiPreference 인자를 생략하거나 기본값인 CAP_ANY를 지정하며, 이 경우 시스템이 알아서 적절한 방법을 선택하여 사용함
  
> - CAP_ANY : 자동 선택
> - CAP_V4L, CAP_V4L2 : V4L/V4L2(리눅스)
> - CAP_FIREWIRE, CAP_FIREWARE, CAP_IEEE1894 : IEEE 1394 드라이버
> - CAP_DSHOW : 다이렉트쇼(DirectShow)
> - CAP_PVAPI : PvAPI, Prosilica GigE SDK
> - CAP_OPENNI : OpenNI
> - CAP_MSMF : 마이크로소프트 미디어 파운데이션(Microsoft Media Foundation)
> - CAP_GSTREAMER : GStreamer
> - CAP_FFMPEG : FFMPEG 라이브러리
> - CAP_IMAGES : OpenCV에서 지원하는 일련의 영상 파일 (ex. img_%02d.jpg)
> - CAP_OPENCV_MJPEG : OpenCV에 내장된 MotionJPEG 코덱

---

- VideoCapture 클래스를 이용하여 컴퓨터에 연결된 카메라 장치를 사용할 수 있음
- 카메라 장치를 열 때에도 VideoCapture 생성자 혹은 VideoCapture::open() 멤버 함수를 사용하는데, 이때는 함수의 인자에 문자열이 아니라 정수 값을 전달
- 아래에 나타낸 VideoCapture 생성자와 VideoCapture::open() 멤버 함수는 카메라 장치를 열 때 사용
  
> ``` C++
> VideoCapture::VideoCapture(int index, int apiPreference = CAP_ANY);
> bool VideoCapture::open(int index, int apiPreference = CAP_ANY);
> ```
> - index : 카메라와 장치 사용 방식 지정 번호
> - apiPreference : 사용할 카메라 캡처 API 백엔드
> - 반환값 : (VideoCapture::open() 함수) 열기가 성공하면 true, 실패하면 false
  
- 카메라 장치를 사용하려고 할 때 VideoCapture 클래스의 생성자 혹은 VideoCapture::open() 함수에 전달하는 정수 값 index는 아래와 같은 형태로 구성됨
  
``` C++
index = camera_id + domain_offset_id
```
  
- 만약 컴퓨터에 한 대의 카메라만 연결되어 있다면 이 카메라의 camera_id 값은 0
- 두 대 이상의 카메라가 연결되어 있다면 각각의 카메라는 0보다 같거나 큰 정수를 ID로 가짐
- domain_offset_id는 카메라 장치를 사용하는 방식을 표현하는 정수 값이며 VideoCaptureAPIs 열거형 상수 중 하나를 지정
- 대부분의 경우 domain_offset_id는 자동 선택을 의미하는 0(CAP_ANY)을 사용하기 때문에 index 값은 결국 camera_id와 같은 값으로 설정
- 즉, 컴퓨터에 연결된 기본 카메라를 사용하려면 index 값으로 0을 지정하고, 두 대의 카메라가 연결되어 있다면 0 또는 1을 지정

---

- 카메라 또는 동영상 파일 열기를 수행한 후에는 VideoCapture::isOpened() 멤버 함수를 이용하여 열기 작업이 성공적으로 수행되었는지 확인하는 것이 좋음

> ``` C++
> bool VideoCapture::isOpened() const;
> ```
> - 반환값 : 카메라 또는 동영상 파일이 사용 가능하면 true, 그렇지 않으면 false

---

- 카메라 장치 또는 동영상 파일의 사용이 끝나면 VideoCapture:release() 함수를 호출하여 사용하던 자원을 해제해야 함
- VideoCapture 클래스의 소멸자에도 VideoCapture::release() 함수와 마찬가지로 사용하고 있던 자원을 모두 해제하는 코드가 들어가 있어서 VideoCapture 객체가 소멸할 때 자동으로 열려 있던 카메라 장치 또는 동영상 파일이 닫히게 됨
- VideoCapture::release() 함수 원형은 아래와 같음
  
> ``` C++
> virtual void VideoCapture::release();
> ```

---

- VideoCapture 클래스를 이용하여 카메라 또는 동영상 파일을 정상적으로 열었다면, 그 후에는 공통의 멤버 함수를 사용하여 클래스를 받아올 수 있음
- VideoCapture 클래스에서 한 프레임을 받아 오기 위해서는 VideoCapture::operator >>() 연산자 재정의 함수 또는 VideoCapture::read() 함수를 사용
> ``` C++
> VideoCapture& VideoCapture::operator >> (Mat& image);
> bool VideoCapture::read(OutputArray image);
> ```
> - image : 다음 비디오 프레임. 만약 더 가져올 프레임이 없다면 비어 있는 행렬로 설정됨
> - 반환값 : 프레임을 받아올 수 없으면 false 반환
  
- \>\> 연산자 재정의와 VideoCapture::read() 클래스 모두 카메라 또는 동영상 파일로부터 다음 프레임을 받아와서 Mat 클래스 형식의 변수 image에 저장
- 사실 >> 연산자 재정의는 함수 내부에서 명시적으로 VideoCapture::read() 함수를 호출하는 형태로 구현되어 있음
- 결국 VideoCapture::read() 함수와 >> 연산자 재정의가 하는 일은 완전히 같지만 사용하는 방법만 다른 형태
- 예를 들어 컴퓨터에 연결된 기본 카메라로부터 한 프레임의 정지 영상을 받아 오려면 아래와 같은 형태로 코드를 작성
  
> ``` C++
> Mat frame1, frame2;
> cap >> frame1; // 1st frame
> cap.read(frame2) // 2nd frame
> ```
  
- 위 코드에서는 첫 번째 프레임 frame1은 VideoCapture::operator >>() 연산자 재정의 함수를 사용하여 받아 왔고, 두 번째 프레임 frame2는 VideoCapture::read() 함수를 사용하여 받음
  
> - `VideoCapture::grab()` : 카메라 장치에 다음 프레임을 획득하라는 명령을 내리는 함수
> - `VideoCapture::retrieve()` : 획득한 프레임을 실제로 받아오는 함수
> - 결국 VideoCapture::read() 또는 VideoCapture::operator >>() 연산자 함수는 VideoCapture::grab()과 VideoCapture::retrieve() 함수를 합쳐 놓은 것이라고 볼 수 있음
>   
> - 만약 컴퓨터에 여러 대의 카메라를 연결하고 여러 카메라로부터 동시에 영상을 획득하고 싶다면 VideoCapture::read() 함수를 쓰는 것보다 VideoCapture::grab()과 VideoCapture::retrieve() 함수를 따로 호출하여 사용하는 것이 좋음
> - 일반적으로 VideoCapture::retrieve() 함수는 VideoCapture::grab() 함수보다 수행 속도가 느린 편
> - 그러므로 같은 시점의 사진을 획득할 때에는 여러 대의 카메라에 대해 차례대로 VideoCapture::grab() 함수를 호출한 후, 다시 VideoCapture::retrieve() 함수를 차례대로 호출하여 실제 프레임을 받아 오는 것이 좋음
> - 여러 대의 카메라 동기화를 고려하는 상황이 아니라면 VideoCapture::read() 함수 또는 >> 연산자 재정의를 사용하는 것이 편리

---

- 현재 열려 있는 카메라 장치 또는 동영상 파일로부터 여러 가지 정보를 받아 오기 위해서는 VideoCapture::get() 함수를 사용

> ``` C++
> double VideoCapture::get(int propId) const;
> ```
> - propId : 속성 ID. VideoCaptureProperties 열거형 중 하나를 지정
> - 반환값 : 지정한 속성 값. 만약 지정한 속성을 얻을 수 없다면 0을 반환
  
- VideoCapture::get() 함수는 인자로 지정한 속성 ID(propId)에 해당하는 속성 값을 반환
- VideoCapture::get() 함수의 인자로 지정할 수 있는 속성 ID는 VideoCaptureProperties 열거형 상수 중 하나를 지정할 수 있으며, 자주 사용되는 상수와 의미를 아래에 기술
  - 아래에 열거된 상수 중에는 동영상 파일에서만 동작하는 속성도 있고, 카메라에 대해서만 사용할 수 있는 속성도 있음
  - 몇몇 속성은 실제 사용하는 카메라 하드웨어와 드라이버가 지원해야 동작하는 속성도 있음
  - 아래에 열거한 속성은 OpenCV에서 지원하는 많은 속성 중 일부이며, 전체 속성은 OpenCV 문서 사이트를 참고

> **주요 VideoCaptureProperties 열거형 상수**
> - CAP_PROP_POS_MSEC : 비디오 파일에서 현재 위치(밀리초 단위)
> - CAP_PROP_POS_FRAMES : 현재 프레임 위치(0-기반)
> - CAP_PROP_POS_AVI_RATIO : [0, 1] 구간으로 표현한 동영상 프레임의 상대적 위치(0: 시작, 1: 끝)
> - CAP_PROP_FRAME_WIDTH : 비디오 프레임의 가로 크기
> - CAP_PROP_FRAME_HEIGHT : 비디오 프레임의 세로 크기
> - CAP_PROP_FPS : 초당 프레임 수
> - CAP_PROP_FOURCC : fourcc 코드(코덱을 표현하는 정수 값)
> - CAP_PROP_FRAME_COUNT : 비디오 파일의 전체 프레임 수
> - CAP_PROP_BRIGHTNESS : (카메라에서 지원하는 경우) 밝기 조절
> - CAP_PROP_CONTRAST : (카메라에서 지원하는 경우) 명암비 조절
> - CAP_PROP_SATURATION : (카메라에서 지원하는 경우) 채도 조절
> - CAP_PROP_HUE : (카메라에서 지원하는 경우) 색상 조절
> - CAP_PROP_GAIN : (카메라에서 지원하는 경우) 감도 조절
> - CAP_PROP_EXPOSURE : (카메라에서 지원하는 경우) 노출 조절
> - CAP_PROP_ZOOM : (카메라에서 지원하는 경우) 줌 조절
> - CAP_PROP_FOCUS : (카메라에서 지원하는 경우) 초점 조절
  
- 예를 들어 시스템 기본 카메라를 열고, 기본 프레임 크기를 확인하려면 아래와 같이 코드를 작성할 수 있음
  
``` C++
VideoCapture cap(0);

int w = cvRound(cap.get(CAP_PROP_FRAME_WIDTH));
int h = cvRound(cap.get(CAP_PROP_FRAME_HEIGHT));
```
  
- VideoCapture::get() 함수는 카메라 또는 동영상 파일 속성을 double 자료형으로 반환
- 그러므로 실제 코드에서 정수형 변수에 프레임 크기를 저장하려면 반올림하여 정수형으로 변환하는 것이 좋음
- 위 소스 코드에서 사용된 cvRound() 함수는 OpenCV에서 제공하는 반올림 함수이고, 변수 w에는 프레임 가로 크기, h에는 프레임 세로 크기가 저장됨

---

- VideoCapture::get() 함수와 반대로 현재 열려 있는 카메라 또는 비디오 파일 재생과 관련된 속성 값을 설정할 때에는 VideoCapture::set() 함수를 사용
> ``` C++
> bool VideoCapture::set(int propId, double value);
> ```
> - propId : 속성 ID. VideoCaptureProperteis 열거형 중 하나를 지정
> - value : 지정할 속성 값
> - 반환값 : 속성 지정이 가능하면 true, 아니면 false

- VideoCapture::set() 함수의 속성 ID에도 앞서 정리했던 VideoCaptureProperties 열거형 상수를 지원
- 만약 video.mp4 파일을 열어서 100번째 프레임으로 이동하려면 아래와 같이 코드를 작성

> ``` C++
> - VideoCapture cap("video.mp4");
> - cap.set(CAP_PROP_POS_FRAMES, 100);
> ```

---

### 4.1.2 카메라 입력 처리하기

- VideoCapture 클래스를 이용하려면 일단 VideoCapture 클래스 객체를 생성해야 함
- VideoCapture 객체는 단순히 VideoCapture 클래스 타입의 변수를 하나 선언하는 방식으로 생성할 수 있음
- 일단 VideoCapture 기본 생성자를 이용하여 변수를 하나 선언하고, 그 다음에는 VideoCapture::open() 멤버 함수를 이용하여 사용할 카메라 장치를 열어야 함
- 컴퓨터에 연결되어 있는 기본 카메라를 사용하려면 VideoCapture::open() 함수의 인자에 0을 지정
  
``` C++
VideoCapture cap;
cap.open(0);
```

- 그런데 VideoCapture 클래스는 객체 생성과 동시에 카메라 장치를 열 수 있는 형태의 생성자도 지원하므로 위 코드는 아래와 같이 한 줄로 쓸 수 있음

``` C++
VideoCapture cap(0);
```
  
- 카메라 장치가 정상적으로 열렸는지는 VideoCapture::isOpened() 멤버 함수를 이용하여 확인할 수 있음
- 만약 VideoCapture::isOpend() 함수가 false를 반환하면 카메라 장치를 사용할 수 없는 상태이므로 예외 처리 코드를 추가하는 것이 좋음
  
``` C++
if (!cap.isOpend()) {
  cerr << "Camera open failed!" << endl;
  return -1;
}
```
  
- 위 소스 코드는 cap.isOpened() 함수가 false를 반환하면 "Camera open failed!" 메시지를 출력하고 함수 진행을 종료

---

- 카메라 장치를 사용할 수 있는 상태라면 이제 카메라 장치로부터 프레임을 받아올 수 있음
- 하나의 프레임은 한 장의 정지 영상을 의미하기 때문에 Mat 클래스 객체에 저장할 수 있고, Mat 객체에 저장된 영상은 imshow() 함수를 사용하여 화면에 출력할 수 있음
- 아래는 카메라로부터 일정 시간 간격마다 프레임을 받아 와서 화면에 출력하는 예제 코드

``` C++
Mat frame;
while (true) {
  cap >> frame;

  imshow("frame", frame);
  waitKey(10);
}
```

- 위 예제 코드는 while 반복문을 무한으로 반복하면서 매 프레임을 화면에 출력
- while 반복문 안에서 일단 VideoCapture::operator >>() 연산자 재정의를 이용하여 카메라 장치로부터 프레임을 받아 와 frame 변수에 저장
- 그리고 imshow() 함수와 waitKey() 함수를 이용하여 받아 온 프레임을 화면에 출력
- waitKey() 함수의 인자에 0을 지정하면 사용자의 키 입력을 무한히 기다리기 때문에 카메라 혹은 동영상을 재생하는 경우에는 waitKey() 함수 인자에 보통 0보다 큰 정수를 입력해야 하며, 카메라 혹은 동영상 파일의 초당 프레임 수를 고려하여 충분히 작은 정수를 입력해야 함
- 위 예제 코드에서는 waitKey() 함수에 10을 전달하였으므로 10ms 동안 기다린 후, 다음 프레임을 받아 오게 됨

<br>

- 그런데 위와 같이 코드를 작성하면 while 반복 문을 빠져나올 수 없기 때문에 사용자가 프로그램을 종료시킬 수 없음
- 그러므로 프로그램 동작 중 사용자가 키보드의 특정 키를 누를 때 종료할 수 있도록 코드를 추가하는 것이 좋음
- 또한 카메라에서 정지 영상 프레임을 제대로 받아 오지 못하는 경우에 대한 예외 처리도 추가하는 것이 좋음
- 이러한 예외 처리 코드를 추가한 소스 코드는 아래와 같음

``` C++
Mat frame;
while (true) {
  cap >> frame;
  if (frame.empty())
    break;

  imshow("frame", frame);

  if (waitKey(10) == 27) // ESC key
    break;
}
```

- 위 소스 코드에는 while 반복문 안에 두 개의 if 조건문이 추가되었음
- 첫 번째 if 문에서는 만약 카메라로부터 받아 온 frame 영상이 비어 있으면 while 반복문을 빠져나가도록 설정
- 두 번째 if 문에서는 waitKey() 함수의 반환값을 조사하여, 만약 사용자의 키 입력이 있었고 해당 키 값이 27이면 while 루프를 빠져나오도록 설정
- 여기서 정수 27은 키보드에서 `Esc` 키에 해당하는 키 값이며, 이 예제 코드는 사용자가 `Esc` 키를 누를 때 while 반복문을 빠져나오게 됨

---

- while 반복문 안에서 카메라로부터 프레임을 받아 왔다면 이후 각 프레임에 다양한 정지 영상 처리 기법을 적용할 수 있음
- 예를 들어 카메라의 매 프레임에 대하여 영상의 반전을 수행하고, 그 결과를 화면에 같이 출력할 수 있음
  - 또는 다양한 영상 처리 기법을 적용하여 사람의 얼굴을 검출하는 등 작업도 수행할 수 있음
  - 카메라 및 동영상 처리는 결국 매 프레임에 대한 정지 영상 처리와 같은 구조

---

- 카메라 처리 소스 코드를 src/ch04_1 프로젝트 파일에 구현 `주석 4-2`

---

### 4.1.3 동영상 파일 처리하기

- 대부분의 동영상 파일은 고유의 코덱(codec)을 이용하여 압축된 형태로 저장됨
- 코덱은 복잡한 알고리즘을 이용하여 대용량 동영상 데이터를 압축하거나, 반대로 압축을 해제하여 프레임을 받아오는 기능을 제공
- OpenCV는 현재 널리 사용되는 MPEG-4, H.264 등 코덱 해석 기능을 제공하기 때문에 VideoCapture 클래스를 사용하면 동영상 파일을 쉽게 불러와서 사용할 수 있음
- OpenCV에서 동영상 파일을 다루는 방법은 카메라 입력 처리하는 방법과 매우 비슷

<br>

- 동영상 파일을 다룰 때에도 우선 VideoCapture 객체를 생성해야 함
- 그리고 VideoCapture::open() 멤버 함수를 이용하여 동영상 파일을 여는 작업을 수행
- 이때 사용하는 VideoCapture::open() 함수는 동영상 파일의 이름을 문자열 형태로 받게 됨
- 예를 들어 현재 프로그램 작업 폴더에 video.mp4 파일이 있다면 아래와 같이 코드 작성

``` C++
VideoCapture cap;
cap.open("video.mp4");
```

- 이처럼 두 줄로 작성된 코드는 동영상 파일 이름을 인자로 갖는 VideoCapture 생성자를 이용하여 한 줄로 바꿔 쓸 수 있음

``` C++
VideoCapture cap("video.mp4");
```
  
- 동영상 파일은 모두 나름대로의 초당 프레임 수, 즉 FPS(frames per second) 값을 가지고 있음
- 동영상 파일을 재생하는 프로그램을 만들 경우 해당 동영상의 FPS 값을 고려하지 않으면 동영상이 너무 빠르거나 느리게 재생되는 경우가 발생
- 그러므로 동영상을 적절한 속도로 재생하려면 동영상의 FPS 값을 참고해야 함
- OpenCV에서 동영상의 FPS 값을 확인하는 코드는 다음과 같음

``` C++
double fps = cap.get(CAP_PROP_FPS);
```

- 동영상 파일의 FPS 값을 이용하면 매 프레임 사이의 시간 간격을 계산할 수 있음
- 이 값은 아래와 같이 간단한 산수를 통해 계산됨

``` C++
int delay = cvRound(1000 / fps);
```

- 예를 들어 초당 30 프레임을 재생하는 동영상의 경우 delay 값은 33이며, 이는 매 프레임을 33ms 시간 간격으로 출력해야 함을 의미
- 여기서 구한 delay 값은 이후 동영상 프레임을 받아와서 화면에 출력한느 반복문 안에서 waitKey() 함수의 인자로 사용됨

---

- 동영상 파일을 불러와서 처리하는 예제 프로그램 소스 코드를 src/ch04_1 프로젝트 파일에 구현 `주석 4-3`
- VideoCapture 클래스를 이용한 동영상 재생 시에는 동영상에 포함된 오디오는 출력되지 않음

---

### 4.1.4 동영상 파일 저장하기

- OpenCV는 카메라 및 동영상 파일의 프레임을 받아 오는 기능뿐만 아니라 일련의 프레임을 동영상 파일로 저장하는 기능도 제공
- OpenCV에서 동영상 파일을 생성하고 프레임을 저장하기 위해서는 VideoWriter 클래스를 사용
- 간략화한 VideoWriter 클래스 정의를 src/ch04_1 프로젝트 파일에 구현 `주석 4-4`

---

- VideoWriter 객체를 생성하였으면 VideoWriter::open() 멤버 함수를 이용하여 저장할 동영상 파일을 쓰기 모드로 열어야 함
- VideoWirter::open() 함수 원형은 아래와 같음

> ``` C++
> VideoWriter::VideoWriter(const STring& filename, int fourcc, double fps, Size frameSize, bool isColor = true);
> bool VideoWriter::open(const String& filename, int fourcc, double fps, Size frameSize, bool isColor = true);
> ```
> - filename : 저장할 동영상 파일 이름
> - fourcc : 동영상 압축 코덱을 표현하는 4-문자 코드
> - fps : 저장할 동영상의 초당 프레임 수
> - frameSize : 동영상 프레임의 가로 및 세로 크기
> - isColor : 이 값이 true이면 컬러 동영상으로 저장하고, false이면 그레이스케일 동영상으로 저장. 이 플래그는 Windows 운영 체제에서만 지원
> - 반환값 : (VideoWriter::open() 함수) 열기가 성공하면 true, 실패하면 false
  
- VideoWriter::open() 함수의 두 번째 인자의 이름 fourcc는 4-문자 코드(four character code)의 약자이며, 말 그대로 네 개의 문자로 구성된 코드
- fourcc는 동영상 파일의 코덱, 압축 방식, 색상 혹은 픽셀 포맷 등을 정의하는 정수 값이며, 코덱을 표현하는 네 개의 문자를 묶어서 fourcc를 생성
- fourcc에 해당하는 정수 값은 VideoWriter::fourcc() 함수를 사용하여 생성할 수 있음
  
> ``` C++
> static int VideoWriter::fourcc(char c1, char c2, char c3, char c4);
> - c1, c2, c3, c4 : 코덱을 표현하는 1byte 문자 네 개
> - 반환값 : 정수형 4-문자 코드
> ```

- VideoWriter::fourcc() 함수를 사용하여 생성할 수 있는 주요 fourcc 코드와 관련 코덱 정보를 아래에 정리
- 좀 더 많은 fourcc 코드와 코덱 정보는 [fourcc 웹 사이트 링크](http://www.fourcc.org/codecs.php) 참조

> - VideoWriter::fourcc('D', 'I', 'V', 'X') : DivX MPEG-4 코덱
> - VideoWriter::fourcc('X', 'V', 'I', 'D') : XVID MPEG-4 코덱
> - VideoWriter::fourcc('F', 'M', 'P', '4') : FFMPEG MPEG4 코덱
> - VideoWriter::fourcc('W', 'M', 'V', '2') : Windows Media Video 8 코덱
> - VideoWriter::fourcc('M', 'J', 'P', 'G') : 모션 JPEG 코덱
> - VideoWriter::fourcc('Y', 'V', '1', '2') : YUV 4:2:0 Planar(비압축)
> - VideoWriter::fourcc('X', '2', '6', '4') : H.264/AVC 코덱
> - VideoWriter::fourcc('A', 'V', 'C', '1') : Advanced Video 코덱
  
- 예를 들어 DivX MPEG-4 코덱을 이용하는 output.avi 동영상 파일을 생성하려면 아래와 같은 형태로 코드를 작성
  
``` C++
VideoWriter video;
int fourcc = VideoWriter::fourcc('D', 'I', 'V', 'X');
video.open("output.mp4", fourcc, fps, Size(w, h));
```

- 위 코드에서 fps는 FPS 값, w와 h는 프레임 크기를 나타냄
- 그런데 VideoWriter 클래스는 VideoWriter::open() 함수와 같은 인자 구성을 갖는 생성자를 지원하기 때문에 위에서 세 줄로 쓴 코드는 아래와 같이 두 줄의 코드로 바꿔 쓸 수 있음
  
``` C++
int fourcc = VideoWriter::fourcc('D', 'I', 'V', 'X');
video.open("output.mp4", fourcc, fps, Size(w, h))
```

---

- 열려 있는 동영상 파일에 새로운 프레임을 추가하기 위해서는 << 연산자 재정의 또는 VideoWriter::wrtie() 함수를 사용
> ``` C++
> VideoWrtier& VideoWriter::operator << (const Mat& image);
> void VideoWriter::writer(InputArray image);
> ```
> - image : 추가할 프레임

- << 연산자 재정의 또는 VideoWriter::write() 함수를 이용하여 프레임을 추가할 때, 새로 추가하는 image 프레임 크기는 동영상 파일을 생성할 때 지정했던 프레임 크기와 같아야 함
- 또한 컬러로 생성된 동영상 파일에 그레이스케일 영상을 추가하면 정상적으로 저장하지 않으므로 주의해야 함

---

- 프레임 저장이 완료되었으면 열려 있던 파일을 닫는 VideoWriter::release() 함수를 호출해야 함
- 다만 VideoWriter 클래스의 소멸자에서 VideoWriter::release() 함수를 호출하기 때문에 VideoWriter 객체가 소멸되면 자동으로 파일이 닫힘

``` C++
virtual void VideoWriter::release();
```

---

- VideoWriter 클래스를 이용하여 실제로 동영상 파일을 생성하는 예제 소스 코드를 src/ch04_1 프로젝트 파일에 구현 `주석 4-5`

---

## 4.2 다양한 그리기 함수

### 4.2.1 직선 그리기

- line() 함수는 영상 위에 직선을 그리는 함수
- line() 함수 원형은 아래와 같음

> ``` C++
> void line(InputOutputArray img, Point pt1, Point pt2, const Scalar& color, int thickness = 1, int lineType = LINE_8, int shift = 0);
> ```
> - img : 입출력 영상
> - pt1 : 시작점
> - pt2 : 끝점
> - color : 선 색상(또는 밝기)
> - thickness : 선 두께
> - lineType : 선 타입, LINE_4, LINE_8, LINE_AA 중 하나를 지정
> - shift : 그리기 좌표 값의 축소 비율(오른쪽 비트 시프트(>>) 연산)
  
- line() 함수는 img 영상 위에 pt1 좌표부터 pt2 좌표까지 직선을 그림
- 선 색상 또는 밝기는 color 인자로 지정할 수 있음
  - 예를 들어 3채널 컬러 영상에 빨간색 선을 그리려면 color 인자에 Scalar(0, 0, 255)를 전달하고, 그레이스케일 영상에 검은색 선을 그리려면 0 또는 Scalar(0)을 전달
- thickness 인자는 선 두께를 의미
- lineType 인자는 직선을 그리는 방식을 지정
  - lineType 인자에는 LineTypes 열거형 상수 중 하나를 지정할 수 있음
- line() 함수의 맨 마지막 인자 shift는 0보다 같거나 큰 정수를 지정할 수 있으며, 지정한 크기만큼 직선 좌표 값을 오른쪽 비트 시프트 연산(>>)을 수행한 후 직선 그리기 작업을 수행
  - shift 인자 값이 0이면 지정한 좌표를 그대로 사용하여 그리기를 수행
- line() 함수의 인자 중에서 thickness, lineType, shift 인자는 기본값이 지정되어 있으므로 생략할 수 있음

> **LineTpyes 열거형 상수 종류**  
> - FILLED(-1) : 내부를 채움(직선 그리기 함수에는 사용 불가)
> - LINE_4(4) : 4방향 연결
> - LINE_8(8) : 8방향 연결
> - LINE_AA(16) : 안티에일리어싱(anti-aliasing)

---

- 만약 화살표 형태의 직선을 그려야 하는 경우에는 arrowedLine() 함수를 이용하면 편리
- arrowedLine() 함수 원형은 아래와 같음

> ``` C++
> void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar& color, int thickness=1, int line_type=8, int shift=0, double tipLength=0.1);
> ```
> - img : 입출력 영상
> - pt1 : 시작점
> - pt2 : 끝점
> - color : 선 색상
> - thickness : 선 두께
> - line_type : 선 타입. Line_4, Line_8, LINE_AA 중 하나를 지정
> - shift : 그리기 좌표 값의 축소 비율(오른쪽 비트 시프트(>>) 연산)
> - tipLength : 전체 직선 길이에 대한 화살표 길이의 비율

- arrowedLine() 함수는 img 영상 위에 pt1 좌표부터 pt2 좌표까지 직선을 그리고, 끝점인 pt2에 화살표 모양의 직선 두 개를 추가로 그림
- 화살표 모양의 직선 길이는 arrowedLine() 함수의 마지막 인자 tipLength를 이용하여 조절할 수 있음
  - tipLength 인자는 기본값으로 0.1이 지정되어 있으며, 이는 직선 전체 길이의 0.1에 해당하는 길이로 화살표를 그리라는 의미
- 나머지 인자는 line() 함수와 동일

---

- drawMarker() 함수는 직선 그리기 함수를 이용하여 다양한 모양의 마커(marker)를 그림
- drawMarker() 함수 원형은 다음과 같음

> ``` C++
> void drawMarker(InputOutputArray img, Point position, const Scalar& color, int markerType = MARKER_CROSS, int markerSize=20, int thickness=1, int line_type=8);
> ```
> - img : 입출력 영상
> - position : 마커 출력 위치
> - color : 선 색상
> - markerType : 마커 종류, MarkerTypes 열거형 상수 중 하나를 지정
> - markerSize : 마커 크기
> - thickness : 선 두께
> - line_type : 선 타입. LINE_4, LINE_8, LINE_AA 중 하나를 지정

- drawMarker() 함수는 img 영상의 position 좌표에 color 색상을 이용하여 마커를 그림
- 마커 종류는 markerType 인자로 지정할 수 있으며, 기본값으로 십자가 모양을 의미하는 MARKER_CROSS가 지정되어 있음
- 만약 다른 종류의 마커를 그리고 싶다면 markerType 인자에 MarkerTypes 열거형 상수 중 하나를 지정 가능

> **MarkerTypes 열거형 상수**
> - MARKER_CROSS : 십자가 모양(+ 모양)
> - MARKER_TILTED_CROSS : 45도 회전된 십자가 모양(× 모양)
> - MARKER_STAR : MARKER_CROSS 모양과 MARKER_TILTED_CROSS 모양이 합쳐진 형태
> - MARKER_DIAMOND : 마름모 모양(◇ 모양)
> - MARKER_SQUARD : 정사각형 모양(□ 모양)
> - MARKER_TRIANGLE_UP : 위로 뾰족한 삼각형(△ 모양)
> - MARKER_TRIANGLE_DOWN : 아래로 뾰족한 삼각형(▽ 모양)

---

- line(), arrowedLine(), drawMarker() 함수를 이용하여 직선을 그리는 예제 소스 코드를 src/ch04_2 프로젝트 파일에 구현 `주석 4-6`

---


### 4.2.2 도형 그리기

- rectangle() 함수는 영상에 사각형을 그리는 함수
- 그림을 그릴 사각형 정보는 사각형의 대각 위치에 있는 두 꼭지점 좌표를 이용하거나 또는 Rect 클래스 타입의 객체를 이용하여 전달할 수 있음
- OpenCV는 아래와 같은 두 가지 형식의 rectangle() 함수를 제공

> ``` C++
> void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar& color, int thickness = 1, int lineType = LINE_8, int shift = 0);
> void rectangle(InputOutputArray img, Rect rec, const Scalar& color, int thickness = 1, int lineType = LINE_8, int shift = 0);
> ```
> - img : 입출력 영상
> - pt1 : 사각형 꼭지점 좌표, Point 객체
> - pt2 : pt1과 대각 방향에 있는 사각형 꼭지점 좌표, Point 객체
> - rec : 사각형 위치 정보, Rect 객체
> - color : 사각형 색상(또는 밝기)
> - thickness : 사각형 외곽선 두께. 이 값이 음수(-1 또는 FILLED)이면 내부를 채움
> - lineType : 선 타입
> - shift : 그리기 좌표 값의 축소 비율(오른쪽 비트 시프트(>>) 연산)

- rectangle() 함수 인자 중 thickness는 도형 외곽선의 두께를 지정할 때 사용
  - 만약 thickness 값에 -1과 같은 음수 또는 FILLED 열거형 상수를 지정하면 내부를 채운 사각형을 그림
- rectangle() 함수 인자 중에서 thickness, lineType, shift 인자는 기본값을 가지고 있으므로 생략할 수 있음

---

- OpenCV에서 원을 그리는 함수는 circle()
- 원을 그리기 위해서는 원의 중심점 좌표와 반지름을 지정해야 함
- circle() 함수 원형은 아래와 같음

> ``` C++
> void circle(InputOutputArray img, Point center, int radius, const Scalar& color, int thickness = 1, int lineType = LINE_8, int shift = 0);
> ```
> - img : 입출력 영상
> - center : 원의 중심
> - radius : 원의 반지름
> - color : 원 색상
> - thickness : 원 외곽선 두께. 이 값이 음수(-1 또는 FILLED)이면 내부를 채움
> - lineType : 선 타입
> - shift : 그리기 좌표 값의 축소 비율(오른쪽 비트 시프트(>>) 연산)

---

- OpenCV에서 타원을 그리는 함수는 ellipse()
- 타원을 그리는 방식은 원보다는 좀 더 복잡
- ellipse() 함수 원형은 아래와 같음

> ``` C++
> void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness = 1, int lineType = LINE_8, int shift = 8, int shift = 0);
> ```
> - img : 입출력 영상
> - center : 타원의 중심
> - axes : 타원의 반지름. Size(x축_반지름, y축_반지름)
> - angle : 타원 회전 각도(x축 기준, 시계 방향)
> - startAngle : 타원 호의 시작 각도(x축 기준, 시계 방향)
> - endAngle : 타원 호의 끝 각도(x축 기준, 시계 방향)
> - color : 타원 색상
> - thickness : 타원 외곽선 두께. 이 값이 음수(-1 또는 FILLED)이면 내부를 채움
> - lineType : 선 타입
> - shift : 그리기 좌표 값의 축소 비율(오른쪽 비트 시프트(>>) 연산)

- ellipse() 함수는 다양한 형태의 타원 또는 타원의 일부인 호를 그릴 수 있음
- 타원의 크기는 axes 인자를 통해 지정
  - axes 인자는 Size 자료형을 사용하며, x축 방향 타원의 반지름과 y축 방향 반지름을 지정
- angle 인자에 0이 아닌 값을 전달하면 회전된 타원을 그릴 수 있음
- startAngle과 endAngle 인자를 적절하게 이용하면 호를 그리는 용도로도 사용 가능
  - 예를 들어 startAngle에는 0을 지정하고 endAngle에는 360을 지정하면 완전한 타원을 그림
  - 만약 startAngle은 0을 지정하고 endAngle에 180을 지정하면 타원의 반에 해당하는 호를 그림
- thickness 인자는 타원 외곽선 두께를 나타내는 인자이며, 이 값을 -1 또는 FILLED로 설정하면 내부를 채운 타원 또는 호를 그림

---

- 임의의 다각형을 그리기 위해서는 polylines() 함수 사용 가능
- polylines() 함수에는 다각형의 꼭지점 좌표를 전달해야 하며, 꼭지점 좌표는 보통 vector<Point> 자료형에 저장하여 전달
- polylines() 함수 원형은 아래와 같음

> ``` C++
> void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar& color, int thickness = 1, int lineType = LINE_8, int shift = 0);
> ```
> - img : 입출력 영상
> - pts : 다각형 외곽 점들의 좌표 배열, 주로 vector<Point> 타입
> - isClosed : 다각형이 닫혀 있는지를 나타내는 플래그. 이 값이 true이면 다각형의 마지막 꼭지점과 첫 번째 꼭지점을 잇는 직선을 추가로 그림
> - color : 선 색상
> - thickness : 선 두께. 이 값이 음수(-1 또는 FILLED)이면 내부를 채움
> - lineType : 선 타입
> - shift : 그리기 좌표 값의 축소 비율(오른쪽 시프트(>>) 연산)

---

- 사각형, 원, 타원, 다각형 그리기 함수를 사용하여 그림을 그리는 예제 코드를 src/ch04_02 프로젝트 파일에 구현 `주석 4-7`
- 원과 타원을 그릴 때에는 선 타입을 LINE_AA로 지정하여 그리는 것이 보기에 좋음

### 4.2.3 문자열 출력하기

- OpenCV는 영상 위에 정해진 폰트로 문자열을 출력하는 putText() 함수를 제공
- putText() 함수 원형은 아래와 같음

> ``` C++
> void putText(InputOutputArray img, const String& text, Point org, int fontFace, double fontScale, Scalar color, int thickness = 1, int lineType = LINE_8, bool bottomLeftOrigin = false);
> ```
> - img : 입출력 영상
> - text : 출력할 문자열
> - org : 영상에서 문자열을 출력할 위치의 좌측 하단 좌표
> - fontFace : 폰트 종류. cv::HersheyFonts에서 선택
> - fontScale : 폰트 크기 확대/축소 비율
> - color : 문자열 색상
> - thickness : 문자열을 그릴 때 사용할 선 두께
> - lineType : 선 타입. LINE_4, LINE_8, LINE_AA 중 하나를 지정
> - bottomLeftOrigin : 이 값이 true이면 영상의 좌측 하단을 원점으로 간주. false이면 좌측 상단이 원점

- putText() 함수는 img 영상의 org 위치에 text로 지정된 문자열을 출력
- 이 때 사용할 폰트 종류는 fontFace 인자로 지정할 수 있고, faceScale 인자를 이용하여 폰트 크기를 조절할 수 있음
  - fontFace 인자에는 HersheyFonts 열거형 상수 값을 지정할 수 있음

> **HersheyFonts 열거형 상수**  
> - FONT_HERSHEY_SIMPLEX : 일반 크기의 산세리프 폰트
> - FONT_HERSHEY_PLAIN : 작은 크기의 산세리프 폰트
> - FONT_HERSHEY_DUPLEX : 일반 크기의 산세리프 폰트(FONT_HERSHEY_SIMPLEX보다 복잡한 형태)
> - FONT_HERSHEY_COMPLEX : 일반 크기의 세리프 폰트
> - FONT_HERSHEY_TRIPLEX : 일반 크기의 세리프 폰트(FONT_HERSHEY_COMPLEX보다 복잡한 형태)
> - FONT_HERSHEY_COMPLEX_SMALL : FONT_HERSHEY_COMPLEX보다 작은 폰트
> - FONT_HERSHEY_SCRIPT_SIMPLEX : 필기체 스타일의 폰트
> - FONT_HERSHEY_SCRIPT_COMPLEX : 필기체 스타일의 폰트(FONT_HERSHEY_SCRIPT_SIMPLEX보다 복잡한 형태)
> - FONT_ITALIC : 이탤릭체를 위한 플래그

- 위 리스트에서 마지막 FONT_ITALIC 상수는 논리합 연산자(|)를 이용하여 다른 HersheyFonts 상수와 함께 사용하며, 이 경우 해당 폰트가 기울어진 이탤릭체로 출력됨
- putText() 함수는 영문자와 숫자를 출력할 수 있으며, 한글은 출력 불가

---

- 각각의 폰트 종류와 실제 출력되는 문자열 형태를 확인하기 위한 예제 코드를 src/ch04_02 프로젝트 파일에 구현 `주석 4-8`

---

- 문자열 출력을 위해 필요한 사각형 영역 크기를 가늠하기 위해 getTextSize() 함수 사용 가능
- 이 함수를 잘 이용하면 문자열이 한쪽으로 치우치지 않고 적당한 위치에 출력되도록 설정할 수 있음
- getTextSize() 함수 원형은 아래와 같음

> ``` C++
> Size getTextSize(const String& text, int fontFace, double fontScale, int thickness, int* baseLine);
> ```
> - text : 출력할 문자열
> - fontFace : 폰트 종류
> - fontScale : 폰트 크기 확대/축소 비율
> - thickness : 문자열을 그릴 때 사용할 선 두께
> - baseLine : (출력) 가장 하단의 텍스트 위치를 기준으로 하는 기준선(baseline)의 y 좌표, 필요 없으면 0 지정
> - 반환값 : 지정한 문자열 출력 시 차지하는 사각형 크기

- getTextSize() 함수는 지정한 문자열, 폰트 종류, 폰트 크기 등을 이용하여 문자열을 출력할 때 차지할 사각형 크기 정보를 반환
- putText() 함수를 이용하여 특정 위치 좌표에 문자열을 출력하는 경우, 보통 문자열 길이와 크기에 따라 문자열이 차지하는 영역 크기가 달라지기 때문에 문자열이 한쪽으로 치우쳐서 나타날 수 있음
- 그러나 getTextSize() 함수가 반환하는 문자열 영역 크기 정보를 이용하면 문자열 출력 위치를 적절하게 조정 가능

---

- getTextSize() 함수를 이용하여 영상 중앙에 문자열을 출력하는 예제 코드를 src/ch04_02 프로젝트 파일에 구현 `주석 4-9`

---

> OpenCV의 그리기 함수는 영상의 픽셀 값을 변경시켜 그림을 그림  
> 그러므로 일반 영상 위에 그리기 함수로 직선, 도형, 문자열을 출력하면 원본 영상의 픽셀 값은 복구 불가능  
> 만약 영상에 그리기를 수행한 후 다시 원본 영상을 사용해야 한다면 미리 원본 영상을 복사해두고 사용해야 함  
> 이 때 대입 연산자 혹은 Mat 클래스 복사 생성자를 사용하여 복사하는 것이 아닌 Mat::clone() 또는 Mat::copyTo() 함수를 사용해야 함  

---

## 4.3 이벤트 처리

### 4.3.1 키보드 이벤트 처리

- waitKey() 함수는 키보드 입력을 처리하는 기본적인 OpenCV 함수
- waitKey() 함수의 원형은 아래와 같음

> ``` C++
> int waitKey(int delay = 0);
> ```
> - delay : 키 입력을 기다릴 시간(밀리초 단위). delay ≤ 0이면 무한히 기다림
> - 반환값 : 눌러진 키 값, 지정한 시간 동안 키가 눌리지 않았으면 -1을 반환

- waitKey() 함수는 delay에 해당하는 밀리초 시간 동안 키 입력을 기다리다가 키 입력이 있으면 해당 키의 아스키 코드(ASCII code) 값을 반환
  - 만약 지정한 시간 동안 키 입력이 없으면 waitKey() 함수는 -1을 반환
- waitKey() 함수의 인자를 지정하지 않거나 0 또는 음수로 설정하면 키 입력이 있을 때까지 무한히 기다리고, 사용자가 키보드를 누르면 눌린 키의 아스키 코드를 반환하면서 함수가 종료됨

---

- 2장에서 구현한 HelloCV 예제 프로그램은 lenna.bmp 영상이 화면에 나타난 상태에서 키보드의 아무 키나 누르면 프로그램이 종료되었음 `ch02/src/HelloCV/main.cpp`
- 만약 특정 키를 눌렀을 때에만 영상 출력 창을 닫게끔 만들려면 waitKey() 함수의 반환값을 조사해야 함
- 예를 들어 lenna.bmp 영상을 화면에 출력한 상태에서 키보드의 `Esc` 키를 누를 때에만 창을 닫게끔 동작시키려면 소스 코드를 아래와 같이 작성 가능

``` C++
Mat img = imread("lenna.bmp", IMREAD_GRAYSCALE);

namedWindow("img");
imshow("img", img);

while (true) {
  if (waitKey() == 27)
    break;
}

destroyWindow("img");
```

- 위 소스 코드에서는 영상을 화면에 출력한 후, while (true) {...} 문장을 이용하여 while 블록을 무한히 수행하도록 설정
- 그리고 while 반복문 안에서는 if 조건문을 사용하여 조건이 참인 경우에만 while 반복문을 빠져나올 수 있도록 설정
- if 조건문에서는 waitKey() 함수를 호출하고, waitKey() 함수 반환값이 27인지를 검사
  - 여기서 숫자 27은 키보드의 `Esc` 키에 해당하는 아스키 코드 값
- 즉, 위 소스 코드는 `Esc` 키를 누를 때에만 while 반복문을 빠져나오고, `Esc` 이외의 키를 누를 때에는 계속 while 반복문 안에서 머물게 됨

---

- 만약 키보드에서 여러 키 입력에 대해 서로 다른 처리를 하고 싶다면 waitKey() 함수의 반환값을 정수형 변수에 저장하였다가 비교하는 작업을 수행
- 여러 키 입력에 대해 서로 다른 동작을 수행하는 예제 프로그램 소스 코드를 src/ch04_3 프로젝트 파일에 구현 `주석 4-10`

---

> Windows 운영 체제에서는 waitKey() 함수를 이용하여 일반적인 키보드 입력은 처리할 수 있지만 함수 키(`F1`, `F2`, ..., `F12`) 또는 `↑`, `↓`, `←`, `→` 화살표 키 등 특수 키 입력은 처리하지 못함  
> 만약 특수 키에 대한 처리를 하고 싶다면 waitKey() 함수 대신 waitKeyEx() 함수를 사용해야 함
> waitKeyEx() 사용법은 waitKey() 함수와 유사하지만 특수 키에 대해 동작한다는 점이 다름
> 
> > ``` C++
> > int waitKeyEx(int delay = 0);
> > ``` 
> > - delay : 키 입력을 기다릴 시간(밀리초 단위). delay ≤ 0이면 무한히 기다림
> > - 반환값 : 눌러진 키 값. 지정한 시간 동안 키가 눌리지 않았으면 -1을 반환
> 
> 주요 특수 키에 대해 waitKeyEx() 함수가 반환하는 정수 값은 아래 목록과 같음
> Windows 운영 체제에서 특수 키에 대한 정의를 16진수를 사용하여 표기하기 때문에 아래 목록에서도 waitKeyEx() 함수 반환값을 16진수로 표기
> > - `insert` : 0x2d0000
> > - `Delete` : 0x2e0000
> > - `Home` : 0x240000
> > - `End` : 0x230000
> > - `Page Up` : 0x210000
> > - `Page Down` : 0x220000
> > - `←` : 0x250000
> > - `↑` : 0x260000
> > - `→` : 0x270000
> > - `↓` : 0x280000
> > - `F1` : 0x700000
> > - `F2` : 0x710000
> > - `F3` : 0x720000
> > - `F4` : 0x730000
> > - `F5` : 0x740000
> > - `F6` : 0x750000
> > - `F7` : 0x760000
> > - `F8` : 0x770000
> > - `F9` : 0x780000
> > - `F10` : 0x790000
> > - `F11` : 0x7a0000
> > - `F12` : 0x7b0000

---

### 4.3.2 마우스 이벤트 처리

- OpenCV는 영상 출력 창에서 발생하는 마우스 이벤트를 사용자에게 전달하는 기능을 제공
- 이를 이용하면 OpenCV에 의해 만들어진 창에서 마우스 클릭에 반응하거나 마우스를 드래그하여 영상에 그림을 그리는 등의 동작을 수행할 수 있음
- OpenCV 응용 프로그램에서 마우스 이벤트를 처리하려면 먼저 마우스 콜백 함수를 등록하고, 이후 마우스 콜백 함수에 마우스 이벤트를 처리하는 코드를 추가해야 함

---

- OpenCV에서 특정 창에 마우스 콜백 함수를 등록할 때에는 setMouseCallback() 함수를 사용할 수 있음
- setMouseCallback() 함수의 원형과 사용법은 아래와 같음
  
> ``` C++
> void setMouseCallback(const String& winname, MouseCallback onMouse, void* userdata = 0);
> ```
> - winname : 마우스 이벤트 처리를 할 창의 이름
> - onMouse : 마우스 이벤트 처리를 위한 콜백 함수 이름
> - userdate : 콜백 함수에 전달할 사용자 데이터의 포인터
  
- setMouseCallback() 함수는 winname 창에서 마우스 이벤트가 발생하면 onMouse로 등록된 콜백 함수가 자동으로 호출되도록 설정
- userdata 인자에는 사용자가 마우스 콜백 함수에 전달하고 싶은 데이터를 void* 형식으로 전달할 수 있음
  - 만약 콜백 함수에 전달할 사용자 데이터가 없다면 userdata 인자는 지정하지 않아도 됨
- setMouseCallback() 함수의 두 번째 인자 onMouse에 지정하는 마우스 콜백 함수는 마우스 이벤트가 발생할 때 자동으로 호출되는 함수이며, 이 콜백 함수의 형식 MouseCallback은 다음과 같이 정의되어 있음
  
> ``` C++
> typedef void (*MouseCallback) (int event, int x, int y, int flags, void* userdata);
> ```

- 즉, 마우스 콜백 함수는 네 개의 정수형과 하나의 void* 타입을 인자로 가지며, void를 반환형으로 사용해야 함
- 마우스 콜백 함수 이름을 반드시 onMouse로 설정해야 하는 것은 아니며, 원하는 다른 이름을 사용해도 됨
- 마우스 콜백 함수의 첫 번째 인자 event에는 MouseEventTypes로 정의된 열거형 상수 중 하나가 전달되며, 그 값과 의미는 아래와 같음
  
> **MouseEventTypes 열거형 상수**  
> - EVENT_MOUSEMOVE(0) : 마우스가 창 위에서 움직이는 경우
> - EVENT_LBUTTONDOWN(1) : 마우스 왼쪽 버튼을 누른 경우
> - EVENT_RBUTTONDOWN(2) : 마우스 오른쪽 버튼을 누른 경우
> - EVENT_MBUTTONDOWN(3) : 마우스 가운데 버튼을 누른 경우
> - EVENT_LBUTTONUP(4) : 마우스 왼쪽 버튼을 떼는 경우
> - EVENT_RBUTTONUP(5) : 마우스 오른쪽 버튼을 떼는 경우
> - EVENT_MBUTTONUP(6) : 마우스 가운데 버튼을 떼는 경우
> - EVENT_LBUTTONDBLCLK(7) : 마우스 왼쪽 버튼을 더블클릭하는 경우
> - EVENT_RBUTTONDBLCLK(8) : 마우스 오른쪽 버튼을 더블클릭하는 경우
> - EVENT_MBUTTONDBLCLK(9) : 마우스 가운데 버튼을 더블클릭하는 경우
> - EVENT_MOUSEWHEEL(10) : 마우스 휠을 앞뒤로 돌리는 경우
> - EVENT_MOUSEHWHEEL(11) : 마우스 휠을 좌우로 움직이는 경우

- 마우스 콜백 함수의 두 번째와 세 번째 인자에는 마우스 이벤트가 발생한 위치의 x 좌표와 y 좌표가 전달됨
- 마우스 콜백 함수의 네 번째 인자 flags는 마우스 이벤트가 발생할 때의 마우스 또는 키보드의 상태 정보를 담고 있음
  - flags 인자에는 MouseEventFlags 열거형 상수의 논리합 조합이 전달됨
  - MouseEventFlags 열거형 상수와 의미는 아래와 같음

> **MouseEventFlags 열거형 상수**
> - EVENT_FLAG_LBUTTON(1) : 마우스 왼쪽 버튼이 눌려 있음
> - EVENT_FLAG_RBUTTON(2) : 마우스 오른쪽 버튼이 눌려 있음
> - EVENT_FLAG_MBUTTON(4) : 마우스 가운데 버튼이 눌려 있음
> - EVENT_FLAG_CTRLKEY(8) : `Ctrl` 키가 눌려 있음
> - EVENT_FLAG_SHIFTKEY(16) : `Shift` 키가 눌려 있음
> - EVENT_FLAG_ALTKEY(32) : `Alt` 키가 눌려 있음

- void* 타입의 다섯 번째 인자에는 setMouseCallback() 함수에서 설정한 사용자 데이터의 포인터가 전달됨
- 만약 setMouseCallback() 함수에서 세 번째 인자 userdata를 설정하지 않았다면 마우스 콜백 함수의 userdata 인자에는 항상 0(NULL)이 전달됨

---

- setMouseCallback() 함수를 이용하여 마우스 이벤트를 처리하는 예제 코드를 src/ch04_4 프로젝트 파일에 구현 `주석 4-11`

---

### 4.3.3 트랙바 사용하기

- OpenCV는 다양한 운영 체제에서 동작하는 라이브러리이기 때문에 범용적인 GUI 기능을 제공하기가 쉽지 않음
- 그럼에도 OpenCV는 Windows, Linux, Mac OS 운영 체제에서 공통으로 사용할 수 있는 트랙바(trackbar) 인터페이스를 제공
- 트랙바는 슬라이더 컨트롤(slider control)이라고도 부르며, 영상 출력 창에 부착되어 프로그램 동작 중에 사용자가 지정된 범위 안의 값을 선택할 수 있음

---

- 트랙바는 사용자가 지정한 영상 출력 창의 상단에 부착되며, 필요한 경우 창 하나에 여러 개의 트랙바를 생성할 수 있음
- 각각의 트랙바에는 고유한 이름을 지정해야 하며, 이 이름은 트랙바 왼쪽에 나타남
- 트랙바 위치는 사용자가 마우스를 이용하여 이동시킬 수 있고, 트랙바의 현재 위치는 트랙바 이름 옆에 함께 표시됨
- 트랙바가 가리킬 수 있는 최대 위치는 트랙바 생성 시 지정할 수 있으며, 최소 위치는 항상 0으로 고정되어 있음

---

- OpenCV에서 트랙바를 생성하려면 createTrackbar() 함수를 사용하며, 이 함수의 원형은 아래와 같음
  
> ``` C++
> int createTrackbar(const String& trackbarname, const String& winname, int* value, int count, TrackbarCallback onChange = 0, void* userdata = 0);
> ```
> - trackname : 트랙바 이름
> - winname : 트랙바를 생성할 창 이름
> - value : 트랙바 위치를 받을 정수형 변수의 주소
> - count : 트랙바 최대 위치
> - onChange : 트랙바 위치가 변경될 때마다 호출되게 만들 콜백 함수 이름(함수의 포인터), 만약 NULL을 지정하면 콜백 함수는 호출되지 않고 value로 지정한 변수 값만 갱신됨
> - userdata : 트랙바 콜백 함수에 전달할 사용자 데이터의 포인터
> - 반환값 : 정상 동작하면 1, 실패하면 0을 반환

- createTrackbar() 함수는 winname 이름의 창에 trackbarname 이름의 트랙바를 부착하고, 트랙바가 움직일 때마다 onChange에 해당하는 트랙바 콜백 함수가 호출되도록 설정
- 생성된 트랙바의 최소 위치는 항상 0으로 설정되고, 최대 위치는 네 번째 인자인 count 값으로 지정
- 정수형 변수를 하나 만들고 그 변수의 주소를 value 인자로 설정하면, 트랙바 위치가 해당 변수에 자동으로 저장됨
- 사용자가 트랙바 콜백 함수에 전달하고 싶은 데이터가 있다면 userdata 인자를 통해 void* 형식으로 전달할 수 있음
- 만약 콜백 함수에 전달할 사용자 데이터가 없다면 userdata 인자는 지정하지 않아도 됨
  
- createTrackbar() 함수의 다섯 번째 인자 onChange에 지정하는 트랙바 콜백 함수는 트랩가 위치가 변경될 때 자동으로 호출되는 함수이며, 이 콜백 함수의 형식 TrackbarCallback은 아래와 같이 정의되어 있음
  
``` C++
typedef void (*TrackbarCallback)(int pos, void* userdata);
```
  
- 즉, 트랙바 콜백 함수는 int와 void* 타입의 인자 두 개를 가지며, 반환형은 void인 형태로 정의해야 함
- 트랙바 콜백 함수 첫 번째 인자에는 현재 트랙바의 위치 정보가 전달되고, 두 번째 인자에는 createTrackbar() 함수에서 지정한 사용자 데이터 포인터 값이 전달됨
- 트랙바 콜백 함수 이름은 사용자 마음대로 지정해도 되지만, 함수의 인자 목록과 반환형은 반드시 정해진 형태를 따라야 함
  - 예를 들어 다음과 같은 형식의 함수는 트랙바 콜백 함수로 사용 가능

  ``` C++
  void my_trackbar_callback(int pos, void* userdata);
  ```

---

- createTrackbar() 함수를 이용하여 트랙바를 만들고 이용하는 예제 코드를 src/ch04_5 프로젝트 파일에 구현 `주석 4-12`

---

- 트랙바를 생성한 후, 트랙바의 현재 위치를 알고 싶다면 getTrackbarPos() 함수를 사용할 수 있음
- 또한 프로그램 동작 중 트랙바 위치를 강제로 특정 위치로 옮기고 싶다면 setTrackbarPos() 함수를 사용할 수 있음
- getTrackbarPos() 함수와 setTrackbarPos() 함수 원형은 아래와 같음
  
> ``` C++
> int getTrackbarPos(const String& trackbarname, const String& winname);
> ```
> - trackbarname : 트랙바 이름
> - winname : 트랙바가 부착되어 있는 창 이름
> - 반환값 : 지정한 트랙바의 현재 위치
  
> ``` C++
> void setTrackbarPos(const String& trackbarname, const String& winname, int pos);
> ```
> - trackbarname : 트랙바 이름
> - winname : 트랙바가 부착되어 있는 창 이름
> - 반환값 : 트랙바를 이동할 위치

--- 

## 4.4 OpenCV 데이터 파일 입출력

### 4.4.1 FileStorage 클래스

- OpenCV에서 데이터 파일 입출력은 FileStorage 클래스가 담당
- FileStorage 클래스는 OpenCV에서 사용하는 데이터의 파일 입출력 기능을 캡슐화하여 지원하는 클래스
- 간략화한 FileStorage 클래스 정의를 src/ch04_6 프로젝트 파일에 구현 `주석 4-13`

---

- FileStorage 클래스를 이용하여 OpenCV 데이터를 저장하거나 읽어 오려면 먼저 FileStorage 객체를 생성해야 함
- FileStorage::open() 함수 원형은 아래와 같음

> ``` C++
> virtual bool FileStorage::open(const String& filename, int flags, const String& encoding = String());
> ```
> - filename : 파일 이름
> - flags : 파일 열기 모드
> - encoding : (XML) 파일 인코딩 형식
> - 반환값 : 정상적으로 파일을 열면 true, 실패하면 false를 반환

- FileStorage::open() 함수의 첫 번째 인자 filename에는 데이터 파일 이름을 지정
  - FileStorage 클래스는 XML, YAML, JSON 형식의 파일 입출력을 지원하며, 사용할 파일 형식은 filename의 확장자에 의해 자동으로 결정됨
    - 예를 들어 filename의 확장자가 *.xml이면 XML 파일 형식을 사용하고, *.yml 또는 *.yaml이면 YAML 파일 형식을 사용
    - filename의 확장자가 *.json이면 JSON 파일 형식을 사용
  - 만약 데이터 파일 이름 뒤에 .gz를 추가하면 데이터 파일을 압축하여 저장
    - 예를 들어 filename을 "mydata.xml.gz"로 설정하면 XML 파일 형식으로 데이터를 저장한 후 gzip 형식으로 압축
- FileStorage::open() 함수의 두 번째 인자 flags는 파일 열기 모드를 결정
  - flags 인자에는 FileStorage::mode 열거형 상수를 지정할 수 있으며 주로 사용되는 상수는 아래와 같음
    
  > **주요 FileStorage::mode 열거형 상수**  
  > - FileStorage::READ : 읽기 모드
  > - FileStorage::WRITE : 쓰기 모드(새로 생성)
  > - FileStorage::APPEND : 추가로 쓰기 모드
  > - FileStorage::MEMORY : 논리합 연산자(|)를 이용하여 FileStorage::READ 또는 FileStorage::WRITE 상수와 함께 사용될 경우, 실제 파일 입출력 대신 메모리 버퍼를 이용한 입출력을 수행
    
- FileStorage::open() 함수의 세 번째 인자에는 XML 파일의 인코딩 형식을 지정하는 문자열을 지정할 수 있으며, 기본 값이 설정되어 있으므로 생략 가능
  
- FileStorage 클래스 타입의 변수를 선언한 후, FileStorage::open() 함수를 이용하여 mydata, json 파일을 쓰기 모드로 열기 위해서는 아래와 같이 소스 코드를 작성
  
``` C++
FileStorage fs;
fs.open("mydata.json", FileStorage::WRITE);
```

- FileStorage 클래스는 FileStorage::open() 맴버 함수와 같은 형식의 인자를 갖는 생성자도 지원
- 파일명 문자열과 파일 열기 모드 열거형 상수를 인자로 받는 생성자를 이용하면 FileStorage 타입의 객체 생성과 동시에 데이터 파일을 특정 모드로 열 수 있음
  - 예를 들어 위에서 두 줄로 작성한 코드는 아래와 같이 한 줄로 쓸 수 있음

``` C++
FileStorage fs("mydata.json", FileStorage::WRITE);
```
  

- FileStorage 객체에서 데이터 파일 열기를 시도한 후에는 해당 파일이 정상적으로 열렸는지 확인하는 것이 좋음
- FileStorage::open() 맴버 함수를 사용하여 파일을 열 경우에는 함수의 반환값을 검사하여 정상 동작을 확인할 수 있지만, FileStorage 생성자를 이용하여 객체 생성과 파일 열기를 한꺼번에 수행하는 경우에는 파일이 정상적으로 열렸는지를 따로 확인해야 함
- 이 때 사용할 수 있는 함수가 FileStorage::isOpened() 함수
- FileStorage::isOpened() 함수는 FileStorage 객체가 사용할 파일이 정상적으로 열린 상태이면 true를 반환

> ``` C++
> virtual bool FileStorage::isOpened() const;
> ```
> - 반환값 : 파일이 정상적으로 열려 있으면 true, 그렇지 않으면 false를 반환
  
- 파일이 정상적으로 열렸다면 이제 데이터를 쓰거나 읽는 작업을 수행할 수 있음
- 일반적으로 FileStorage 클래스를 이용하여 파일에 데이터를 저장할 때에는 << 연산자 재정의 함수를 사용
- 반대로 파일로부터 데이터를 읽어 오는 작업을 할 때에는 >> 연산자 재정의 함수를 사용
  
- FileStorage 객체를 이용하여 파일 입출력 작업이 완료되면 FileStorage::release() 함수를 호출해야 함
- FileStorage::release() 함수는 사용하고 있던 파일을 닫고 메모리 버퍼를 해제
  
``` C++
virtual void FileStorage::release();
```

### 4.4.2 데이터 파일 저장하기

- FileStorage 클래스를 이용하여 XML/YAML/JSON 파일을 쓰기 모드로 열었다면 C/C++ 자료형, STL 클래스, OpenCV 클래스 형식의 데이터를 파일에 저장할 수 있음
- FileStorage 클래스를 이용하여 데이터를 파일에 저장할 때는 보통 << 연산자 재정의 함수를 사용
- FileStorage 클래스 객체에 데이터를 저장할 때 사용하는 << 연산자 재정의 함수 원형은 아래와 같음
  
> ``` C++
> template<typename _Tp>
> static FileStorage& operator << (FileStorage& fs, const _Tp& value);
> static FileStorage& operator << (FileStorage& fs, const String& str);
> static FileStorage& operator << (FileStorage& fs, const char& str);
> ```
> - fs : FileStorage 객체
> - value : 저장할 데이터(C/C++ 기본 자료형, 벡터, 클래스 등)
> - str : 문자열(이름 또는 값)
> - 반환값 : FileStorage 객체의 참조
  
- FileStorage 객체를 사용하는 << 연산자 재정의는 함수 템플릿으로 구성되어 있어서 다양한 자료형의 데이터와 함께 사용될 수 있음
  - 즉, char, int, float, double 등 C/C++ 기본 자료형과 string, vector 같은 STL 클래스 객체, 그리고 OpenCV에서 사용하는 Mat, Scalar, Point, Size, Rect 등 클래스 객체를 저장할 수 있음
- FileStorage 클래스를 이용하여 파일에 여러 개의 데이터를 저장할 때에는 데이터의 구분을 위한 문자열 형식의 이름을 함께 저장
  - 즉, FileStorage 객체에 데이터 이름을 먼저 저장한 후, 실제 저장할 데이터를 저장
  - 예를 들어 C/C++에 int형 데이터 2019를 "year"라는 이름으로 저장하려면 아래와 같이 코드를 작성, fs는 쓰기 모드로 생성된 FileStorage 객체
    
  ``` C++
  int year = 2019;
  fs << "year";
  fs << year;
  ```
    
  - FileStorage 클래스와 함께 사용하는 << 연산자 재정의 함수는 사용된 FileStorage 객체를 참조 형태로 반환
  - 그러므로 위에서 데이터의 이름과 값을 저자아기 위해 두 줄로 작성한 코드는 아래와 같이 한 줄의 코드로 바꿔서 쓸 수 있음

  ``` C++
  int year = 2019;
  fs << "year" << year;
  ```

---

- FileStorage 클래스를 이용하여 여러 형식의 데이터를 파일에 저장하는 예제 코드를 src/ch04_6 프로젝트 파일에 구현 `주석 4-14`

---

### 4.4.3 데이터 파일 불러오기

- FileStorage 클래스를 이용하여 데이터 파일을 읽어 오려면 먼저 FileStorage 객체를 생성하고, 그 다음 실제 사용할 데이터 파일을 읽기 모드로 열어야 함
- FileStorage 클래스의 생성자 중에서 파일 이름과 열기 모드를 지정하는 생성자를 이용하여 두 가지 작업을 한꺼번에 수행할 수 있음
- 아래는 FileStorage 객체 fs를 선언함과 동시에 mydata.json 파일을 읽기 모드로 여는 예제 코드

``` C++
FileStorage fs("mydata.json", FileStorage::READ);
```

- FileStorage 객체가 XML/YAML/JSON 파일을 읽기 모드로 열면 FileStorage 객체는 파일 전체를 분석하여 계층적 구조를 갖는 노드(node) 집합을 구성
  - 노드는 이름과 값으로 구성되어 있는 하나의 데이터를 의미
  - 하나의 노드는 하나의 정수 혹은 문자열을 저장하고 있는 경우도 있고, 여러 데이터의 집합으로 구성되기도 함
- OpenCV는 이러한 노드를 FileNode 클래스를 이용하여 표현
- 특정 이름으로 저장되어 있는 FileNode 객체에 접근하려면 FileStorage::operator[]() 연산자 재정의 함수를 사용

> ``` C++
> FileNode FileStorage::operator[](const char* nodename) const;
> ```
> - nodename : 노드 이름
> - 반환값 : FileNode 객체

- 일단 노드 이름을 이용하여 FileNode 객체를 얻어 온 후에는 FileNode 클래스의 >> 연산자 재정의 함수를 이용하여 노드에 저장된 데이터 값을 받아올 수 있음
- FileNode 객체와 함께 사용하는 >> 연산자 재정의 함수는 아래와 같음
  
> ``` C++
> template<typename _Tp>
> static void operator >> (const FileNode& n, _Tp& value);
> template<typename _Tp>
> static void operator >> (const FileNode& n, std::vector<_Tp>& vec);
> ```
> - n : FileNode 객체
> - value : 받아올 데이터 형식(C/C++ 기본 자료형, 벡터, 클래스 등)에 맞는 변수 이름
> - vec : STL vector 형식으로 저장된 데이터를 불러올 때 사용
   
- 재정의된 >> 연산자 함수를 사용하여 데이터를 읽어 오려면 >> 연산자 왼쪽에 FileNode 객체 이름을 쓰고, >> 연산자 오른쪽에는 받아올 데이터 형식에 맞는 변수 이름을 적음
- 예를 들어 데이터 파일에 "year"라는 이름으로 저장되어 있는 정수형 데이터를 읽어 와서 변수 year에 저장하려면 아래와 같이 코드를 작성, fs는 읽기 모드로 생성된 FileStorage 객체
  
``` C++
int year;
FileNode fn = fs["year"];
fn >> year;
```
  
- 위 코드에서 변수 fn는 임시로 사용된 후 필요가 없어지므로 굳이 변수로 선언하지 않는 것이 일반적
- 그러므로 위 코드는 보통 아래와 같은 형태로 사용
  
``` C++
int year;
fs["year"] >> year;
```

- 위 예제 코드는 FileStorage 객체 fs로부터 "year"라는 노드 이름의 데이터를 읽어 와서 year 변수에 저장
- 결국 FileStorage 클래스를 이용하여 파일을 읽을 때에는 FileNode 클래스의 객체를 명시적으로 사용하지 않아도 되며, 데이터 노드 이름과 자료형을 제대로 알고 있다면 어떠한 데이터도 쉽게 읽을 수 있음
  
---

- FileStorage 클래스를 이용하여 파일로부터 데이터를 읽어 오는 예제 코드를 src/ch04_6 프로젝트 파일에 구현 `주석 4-15`

---

## 4.5 유용한 OpenCV 기능

### 4.5.1 마스크 연산

- OpenCV에서는 임의의 모양의 ROI 설정을 위하여 일부 행렬 연산 함수에 대해 마스크(mask) 연산을 지원
- 마스크 연산을 지원하는 OpenCV 함수는 보통 입력 영상과 크기가 같고 깊이가 CV_8U인 마스크 영상을 함께 인자로 전달받음
- 마스크 영상이 주어질 경우, 마스크 영상의 픽셀 값이 0이 아닌 좌표에 대해서만 연산이 수행
- 일반적으로 마스크 영상은 사람의 눈으로도 구분이 쉽도록 픽셀 값이 0 또는 255로 구성된 흑백 영상이 사용됨

---

- Mat::setTo() 함수는 마스크 연산을 지원하는 함수로, 함수의 원형은 아래와 같음
  
> ``` C++
> Mat& Mat::setTo(InputArray value, InputArray mask = noArray());
> ```
> - value : 행렬 원소에 설정할 값
> - mask : 마스크 행렬. 마스크 행렬의 원소가 0이 아닌 위치에서만 value 값이 설정됨. 행렬 전체 원소 값을 설정하려면 noArray() 또는 Mat()을 지정
> - 반환값 : Mat 객체의 참조

  
- Mat::setTo() 함수의 두 번째 인자 mask에 마스크 영상을 지정할 수 있음
  - 기본값으로 설정되어 있는 noArray()를 mask 인자로 지정하면 입력 행렬의 모든 원소 값을 value 값으로 설정하고, 적절한 마스크 영상을 mask 인자로 지정하면 특정 영역에 대해서만 픽셀 값을 설정할 수 있음
  - 이때 마스크 영상은 Mat::setTo()를 호출하는 대상 행렬과 크기가 같아야 함

---

- Mat::setTo() 함수에서 마스크 영상을 사용하는 예제 코드를 src/ch04_7 프로젝트 파일에 구현 `주석 4-16`

---

- Mat::copyTo() 함수는 두 가지 형태로 정의되어 있음
- 하나는 복사할 대상 행렬 하나만 인자로 받고, 다른 하나는 복사할 대상 행렬과 마스크 영상 두 개를 인자로 받음
- 마스크 연산을 지원하는 Mat::copyTo() 함수 원형은 아래와 같음

> ``` C++
> void Mat::copyTo(OutputArray m, InputArray mask) const;
> ```
> - m : 복사본이 저장될 행렬. 만약 *this 행렬과 크기 및 타입이 다르면 메모리를 새로 할당한 후 픽셀 값을 복사
> - mask : 마스크 행렬. 마스크 행렬 원소 값이 0이 아닌 좌표에서만 행렬 원소를 복사. mask 행렬은 *this와 같은 크기이고 깊이는 CV_8U이어야 함
  
- 마스크 연산을 지원하는 Mat::copyTo() 함수는 mask 영상의 픽셀 값이 0이 아닌 위치에서만 *this 행렬 원소 값을 행렬 m으로 복사
- 만약 Mat::copyTo() 함수를 호출하는 *this 행렬과 인자로 전달된 m 행렬이 서로 크기 또는 타입이 같지 않을 경우, Mat::copyTo() 함수 내부에서 m.create() 함수를 호출하여 대상 영상 m을 새롭게 생성한 후 마스크 영상을 고려하여 픽셀 값을 복사
- 만약 *this 행렬과 m 행렬이 서로 크기와 타입이 같다면 m 행렬 원소 값을 그대로 유지한 상태에서 *this 행렬의 픽셀 값을 복사

---

- Mat::copyTo() 함수의 동작 특성을 이용하여 두 장의 영상을 합성하는 예제 코드를 src/ch04_7 프로젝트 파일에 구현 `주석 4-17`  

---

### 4.5.2 연산 시간 측정

- OpenCV는 정밀한 시간 측정 방법을 제공
- 원래 특정 프로그램의 동작 시간을 츶겅하는 C/C++ 소스 코드 작성 방법은 운영 체제마다 각기 다르지만 OpenCV 라이브러리를 이용하면 운영 체제에 상관없이 통일된 인터페이스 함수를 사용하여 연산 시간을 측정할 수 있음
- OpenCV에서는 getTickCount() 함수와 getTickFrequency() 함수를 사용하여 특정 연산의 수행 시간을 측정

---

- getTickCount() 함수 원형은 아래와 같음
  
> ``` C++
> int64 getTickCount(void)
> ```
> - 반환값 : 시스템의 현재 틱(tick) 횟수

- getTickCount() 함수는 컴퓨터 시스템의 특정 시점(ex. 컴퓨터 부팅 시점)부터 현재까지 발생한 틱(tick) 횟수를 반환
  - 여기서 틱 횟수는 컴퓨터 시스템에서 발생하는 클럭(clock)처럼 매우 빠르게 증가하는 성능 측정 계수를 의미하며, 컴퓨터 성능에 따라 틱 횟수는 빠르게 증가할 수도 있고 조금 느리게 증가할 수도 있음
- getTickCount() 함수의 반환형으로 사용되는 int64는 OpenCV에서 64비트 정수형을 저장하기 위해 사용하는 자료형

---

- 보통 특정 연산에 걸리는 시간을 측정하기 위해서는 특정 연산 수행 전에 getTickCount() 함수 반환값을 저장해놓고, 연산 후에 다시 getTickCount() 함수 반환값을 구하여 그 차이를 계산
- 이렇게 계산되는 틱 횟수 차이 값은 사용하고 있는 컴퓨터 시스템의 성능에 따라 다르게 측정됨
- 그러므로 실제 연산 시간을 알아내기 위해서는 틱 횟수 차이를 시스템의 틱 주파수(tick frequency)로 나누는 작업이 동반되어야 함
  - 틱 주파수란 1초 동안 발생하는 틱 횟수를 의미하며, OpenCV에서는 getTickFrequency() 함수를 이용하여 시스템 틱 주파수를 구할 수 있음
  
  > ``` C++
  > double getTickFrequency(void)
  > ```
  > - 반환값 : 시스템의 초당 틱 횟수

---

- 특정 연산이 수행되는 시간을 측정하기 위해서는 getTickCount() 함수와 getTickFrequency() 함수를 같이 조합해서 사용
- 만약 특정 함수가 수행되는 시간을 밀리초 단위로 측정하려면 아래와 같이 코드를 작성

---

``` C++
int64 t1 = getTickCount();
  
my_func(); // do something
 
int64 t2 = getTickCount();
double ms = (t2 - t1) * 1000 / getTickFrequency();
```

- 위 코드에서는 my_func() 함수 호출 전후에 각각 getTickCount() 함수를 호출하여 틱 횟수 차이 (t2 - t1)을 계산
- 이 차이 값을 getTickFrequency() 함수 반환값으로 나누면 초 단위의 수행 시간이 측정됨
- 그러나 대부분의 영산이 보통 1초 이내에 수행되는 경우가 많기 때문에 위 소스 코드에서는 연산 시간에 1000을 곱하여 밀리초 단위의 연산 시간을 변수 ms에 저장

---

- getTickCount()와 getTickFrequency() 함수를 조합하여 사용하면 특정 연산 시간을 정확하게 측정할 수 있지만, 사용법이 다소 생소하고 복잡할 수 있음
- 그래서 OpenCV 3.2.0 버전부터 연산 시간 측정을 위한 TickMeter라는 이름의 클래스를 새롭게 제공
- TickMeter 클래스는 직관적인 이르의 시간 측정 멤버 함수를 가지고 있어서 OpenCV 초보자들도 쉽게 사용 가능
- 간략화한 TickMeter 클래스 정의를 src/ch04_7 프로젝트 파일에 구현 `주석 4-18`

---

- TickMeter 클래스를 이용하여 특정 연산이 수행되는 시간을 측정하려면 아래와 같은 형태로 코드를 작성

``` C++
TickMeter tm;
tm.start();

my_func(); // do something

tm.stop();
double ms = tm.getTimeMilli();
```

- TickMeter 클래스를 이용하여 연산 시간을 측정하기 위해서는 TickMeter 타입의 변수를 먼저 선언해야 함
- 위 예제 코드에서는 tm이라는 이름의 변수를 선언한 후 시간 측정을 시작하는 위치에서 tm.start() 함수를 호출하고, 시간 측정을 마치는 위치에서 tm.stop() 함수를 호출
- tm.start() 함수가 호출된 시점에서 tm.stop() 함수가 호출된 시점까지의 시간 간격은 TickMeter 내부 멤버 함수에 저장되고, 이 시간 간격을 밀리초 단위로 받아 오기 위하여 tm.getTimeMilli() 함수를 사용
- 위 예제 코드에서는 double형 변수 ms에 my_func() 함수 실행 시간이 저장됨

---

- TickMeter 클래스를 이용하여 간단한 영상 처리 실행 시간을 측정하는 예제 코드를 src/ch04_7 프로젝트 파일에 구현 `주석 4-19`

---

### 4.5.3 유용한 OpenCV 함수 사용법

#### sum() 함수와 mean() 함수

- OpenCV에서 Mat 행렬의 원소 합을 구하고 싶을 때에는 **sum() 함수**를 사용하고, 평균을 구하고 싶을 때에는 **mean() 함수**를 사용
- 이 두 함수는 4채널 이하의 행렬에 대해서만 동작하며, 합과 평균을 Scalar 타입으로 반환
- 두 함수의 원형은 아래와 같음
  
> ``` C++
> Scalar sum(InputArray src);
> ```
> - src : 입력 행렬(1~4채널)
> - 반환값 : 각 채널의 합
  
> ``` C++
> Scalar mean(InputArray src, InputArray mask = noArray());
> ```
> - src : 입력 행렬(1~4채널)
> - mask : 마스크 영상
> - 반환값 : 각 채널의 평균
  
- mean() 함수는 마스크 연산을 지원하므로 필요한 경우 mask 영상을 지정하여 특정 영역의 원소 평균을 구할 수도 있음
- sum() 함수와 mean() 함수의 반환형이 Scalar이므로 이 두 함수를 이용하여 행렬의 합 또는 평균을 구할 때에는 잘 확인해야 함
- 만약 입력 행렬이 그레이스케일 영상처럼 1채널 행렬이라면 Scalar 자료형의 첫 번째 원소에 행렬 합 또는 평균이 저장됨
- 입력 행렬이 3채널 컬러 영상이라면 Scalar 자료형의 처음 세 원소에 각각 파란색, 녹색, 빨간색 성분의 합 또는 평균이 저장됨
  
---

- 아래는 그레이스케일 레나 영상에 대하여 모든 픽셀 값의 합과 평균을 구하는 예제 코드
  
``` C++
Mat img = imread("lenna.bmp", IMREAD_GRAYSCALE);

cout << "Sum: " << (int)sum(img)[0] << endl; 
cout << "Mean: " << (int)mean(img)[0] << endl;
```

- 위 예제 코드에서 sum(src)는 Scalar 자료형을 반환
- 그리고 Scalar 자료형에서 첫 번째 원소 값을 참조하기 위해 sum(src) 코드 뒤에 [0]을 추가로 붙여서 코드를 작성
- 위 예제 코드를 실행하면 콘솔 창에 아래 문자열이 출력됨

```
Sum: 32518590
Mean: 124
```

---

#### minMaxLoc() 함수

- minMaxLoc() 함수는 주어진 행렬의 최솟값, 최댓값을 찾는 함수
- 최솟값, 최댓값이 있는 좌표 정보도 함께 알아낼 수 있음
- minMaxLoc() 함수 원형은 아래와 같음
  
> ``` C++
> void minMaxLoc(InputArray src, double* minVal, double* maxVal = 0, Point* minLoc = 0, Point* maxLoc = 0, InputArray mask = noArray());
> ```
> - src : 입력 영상, 단일 채널
> - minVal : 최솟값을 받을 double형 변수의 주소. 필요 없으면 0을 지정
> - maxVal : 최댓값을 받을 double형 변수의 주소. 필요 없으면 0을 지정
> - minLoc : 최솟값 위치 좌표를 받을 Point형 변수의 주소. 필요 없으면 0을 지정
> - maxLoc : 최댓값 위치 좌표를 받을 Point형 변수의 주소. 필요 없으면 0을 지정
> - mask : 마스크 영상. 마스크 영상의 픽셀 값이 0이 아닌 위치에서만 연산을 수행
  
- minMaxLoc() 함수는 행렬 또는 영상에서 최솟값, 최댓값, 그리고 최솟값과 최댓값 위치를 찾을 때 사용
- minMaxLoc() 함수는 마스크 연산을 지원하므로 행렬 일부 영역에서의 최솟값, 최댓값 또는 해당 위치를 구할 수도 있음
- 만약 주어진 행렬에서 가장 큰 원소 값만 알고 싶다면 maxVal 인자만 설정하고, 나머지 인자에는 0(NULL)을 전달
  
---

- minMax 함수를 사용하여 레나 영상 img에서 최소 그레이스케일 값과 최대 그레이스케일 값, 그리고 해당 좌표를 출력하려면 아래와 같이 코드 작성 가능
  
``` C++
double minVal, maxVal;
Point minPos, maxPos;
minMaxLoc(img, &minVal, &maxVal, &minPos, &maxPos);

cout << "minVal: " << minVal << " at " << minPos << endl;
cout << "maxVal: " << maxVal << " at " << maxPos << endl;
```

- 위 예제 코드에서 최솟값과 최댓값을 받을 변수 minVal, maxVal는 double형으로 선언하였고, 최솟값과 최댓값 위치를 받을 변수 minPos, maxPos는 Point 자료형으로 선언
- minMaxLoc() 변수 안에는 해당 변수의 주소를 넘겨주어야 하므로 & 연산자를 함께 사용
- 위 예제 코드의 실행 결과는 아래와 같음
  
``` C++
minVal: 25 at [508, 71]
maxVal: 245 at [116, 273]
```

- 그레이스케일 레나 영상에서 가장 작은 픽셀 값은 25이고, 해당 위치는 (508, 71)
- 그레이스케일 레나 영상에서 가장 큰 픽셀 값은 245이고, 해당 위치는 (116, 273)

---

#### normalize() 함수

- normalize() 함수는 행렬의 노름(norm) 값을 정규화하거나 또는 원소 값 범위를 특정 범위로 정규화할 때 사용하는 함수
- normalize() 함수 원형은 아래와 같음
  
> ``` C++
> void normalize(InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0, int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray());
> ```
> - src : 입력 행렬
> - dst : 출력 행렬
> - alpha : (노름 정규화인 경우) 목표 노름 값, (원소 값 범위 정규화인 경우) 최솟값
> - beta : (원소 값 범위 정규화인 경우) 최댓값
> - norm_type : 정규화 타입. NORM_INF, NORM_L1, NORM_L2, NORM_MINMAX 중 하나를 지정
> - dtype : 결과 영상의 타입
> - mask : 마스크 영상
  
- normalize() 함수는 norm_type 인자에 따라 동작이 결정됨
- norm_type이 NORM_INF, NORM_L1, NORM_L2인 경우에는 $||dst||_{L_p} = alpha(p=\inf, 1, 2)$ 수식을 만족하도록 입력 행렬 원소 값의 크기를 조정
  
$$
||dst||_{L_∞} = max_i |dst_i| = alpha\\
||dst||_{L_1} = \sum_{i}^{}{{|dst_i|}} = alpha\\
||dst||_{L_2} = \sqrt{\sum_{i}{dst_i}^{2}} = alpha\\
$$
  
- 만약 norm_type 인자가 NORM_MINMAX인 경우에는 src 행렬의 최솟값이 alpha, 최댓값이 beta가 되도록 모든 원소 값 크기를 조절
- 많은 OpenCV 예제 코드에서 NORM_MINMAX 타입으로 normalize() 함수를 사용하고 있으며, 특히 실수로 구성된 행렬을 그레이스케일 영상 형태로 변환하고자 할 때 normalize() 함수를 사용하면 유용
- 예를 들어 -1에서 1 사이의 실수로 구성된 1 × 5 행렬을 0부터 255 사이의 정수 행렬로 변환하려면 아래와 같이 코드를 작성

``` C++
Mat src = Mat_<float>({1, 5}, {-1.f, -0.5f, 0.f, 0.5f, 1.f});

Mat dst;
normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC1);

cout << "src: " << endl;
cout << "dst: " << endl;
```
  
- 위 예제 코드는 주어진 행렬의 최솟값은 0, 최댓값은 255가 되도록 크기를 조정하고, 결과 행렬의 타입이 CV_8UC1이 되도록 변경
- src 행렬의 최솟값이 -1이고, 최댓값이 1이므로 -1부터 1까지의 범위가 0부터 255까지의 범위가 되도록 src 원소 값을 선형 변환
- 위 코드의 실행 결과는 아래와 같음

```
src: [-1, -0.5, 0,  0.5,  1] 
dst: [  0,  64, 128,  191,  255]
```

---

#### cvRound() 함수

- 영상 처리를 수행하다 보면 내부 연산은 실수를 사용하고, 최종적인 결과는 정수로 변환하는 경우가 종종 있음
- 실수 값을 정수로 변환할 때는 주로 반올림을 사용하며, OpenCV에서는 실수 값의 반올림 연산을 위해 cvRound() 함수를 제공
- cvRound() 함수 원형은 아래와 같음

> ``` C++
> int cvRound(double value);
> int cvRound(float value);
> ```
> - value : 입력 실수 값. 만약 value가 INT_MIN과 INT_MAX 사이를 벗어날 경우 알 수 없는 값이 반환됨
> - 반환값 : 반올림한 정수 값
  
- cvRound() 함수는 value 인자의 소수점 아래가 0.5보다 크면 올림을 수행하고, 0.5보다 작으면 내림을 수행
  - 소수점 아래가 정확하게 0.5인 경우에는 가장 가까운 짝수로 반올림을 수행
- 이외에도 OpenCV는 실수의 올림을 수행 수행하는 cvCeil() 함수와 내림을 수행하는 cvFlooar() 함수도 제공
- cvRound(), cvCeil(), cvFloor() 함수는 cv 네임스페이스로 선언되지 않은 전역 함수
- 아래는 cvRound() 함수의 예제 코드
  
``` C++
cout << "cvRound(2.5): " << cvRound(2.5) << endl;
cout << "cvRound(2.51): " << cvRound(2.51) << endl;
cout << "cvRound(3.4999): " << cvRound(3.4999) << endl;
cout << "cvRound(3.5): " << cvRound(3.5) << endl;
```
  
- 위 코드의 실행 결과는 아래와 같음
  
```
cvRound(2.5): 2
cvRound(2.51): 3
cvRound(3.4999): 3
cvRound(3.5): 4
```