# 3. OpenCV 주요 클래스

## 3.1 기본 자료형 클래스

### 3.1.1 Point_ 클래스
- Point_ 클래스는 2차원 평면 위에 있는 점의 좌표를 표현하는 탬플릿 클래스
- Point_ 클래스는 2차원 좌표를 나타내는 x와 y라는 이름의 맴버 변수를 가지고 있음
- 간략화한 Point_ 클래스 정의를 src\ch03_1 프로젝트 파일에 구현 `주석 3-1`

<hr>

- Point_ 클래스는 템플릿 클래스이기 때문에 실제로 사용할 때에는 어떤 자료형으로 좌표를 표현할 것인지를 명시해야 함
  - 예를 들어 정수 좌표를 표현하려면 Point_<int> 클래스를 사용
- 다만 Point_ 클래스를 사용할 때마다 자료형을 명시하는 것이 다소 번거로울 수 있어서 OpenCV는 자주 사용하는 자료형에 대하여 Point_ 클래스 이름을 재정의하여 제공
  - 즉, 정수형 int 자료형으로 점의 좌표를 표현하려면 Point2i 클래스를 사용하고, float 자료형을 사용하려면 Point2f 클래스를 사용
- 정수형 좌표를 표현하는 경우가 많기 때문에 Point2i 클래스는 좀 더 일반적인 이름인 Point 클래스로 다시 재정의
- 그러므로 OpenCV 소스 코드에서 Point 클래스는 2차원 정수 좌표계에서 좌표를 표현하는 자료형으로 취급하면 됨

<hr>

- 2차원 정수 좌표계에서 점의 좌표를 표현하는 방법을 src\ch03_1 프로젝트 파일에 구현 `주석 3-1-1`

<hr>

### 3.1.2 Size_ 클래스
- 영상 또는 사각형의 크기를 표현할 때에는 Size_ 클래스를 사용
- Size_ 클래스는 사각형의 가로와 세로 크기를 나타내는 width와 height 맴버 변수를 가지고 있음
- 간략화한 Size_ 클래스 정의를 src\ch03-1 프로젝트 파일에 구현 `주석 3-2`

<hr>

- Point_ 클래스와 마찬가지로 Size_ 클래스도 탬플릿으로 정의되어 있으며, 다양한 자료형에 대해 이름이 재정의되어 있음
  - 사각형 영역의 가로 및 세로 크기를 int 자료형으로 표현하려면 Size2i 클래스를 사용하고, float 자료형을 사용하려면 Size2f 클래스를 사용
- 정수형으로 가로, 세로 크기를 표현하는 경우가 많기 때문에 Size2i는 다시 Size라는 이름으로 재정의되어 있음
  - 즉, Size 클래스는 정수형 맴버 변수 width, height를 가지고 있는 사각형 크기 표현 클래스

<hr>

- 2차원 정수 좌표계에서 크기를 표현하는 방법을 src\ch03_1 프로젝트 파일에 구현 `주석 3-2-1`

<hr>

### 3.1.3 Rect_ 클래스
- OpenCV에서 사각형의 위치와 크기 정보를 표현할 때에는 Rect_ 클래스를 사용
- Rect_ 클래스는 사각형의 좌측 상단 점의 좌표를 나타내는 x, y 맴버 변수와 사각형의 가로 및 세로 크기를 나타내는 width, height 맴버 변수를 가지고 있음
- 간략화한 Rect_ 클래스 정의를 src\ch03-1 프로젝트 파일에 구현 `주석 3-3`

<hr>

- Rect_ 클래스도 템플릿으로 정의되어 있으며, 다양한 자료형에 대해 이름이 재정의되어 있음
  - int 자료형을 이용하여 사각형 정보를 표현하려면 Rect2i 클래스를 사용하고, float 자료형으로 사각형을 표현하려면 Rect2f 클래스를 사용
- 정수형으로 사각형 정보를 표현하는 경우가 많기 때문에 Rect2i는 다시 Rect라는 이름으로 재정의되어 있음
  - 즉, Rect 클래스는 정수형 맴버 변수 x, y, width, height를 가지고 있는 사각형 표현 클래스

<hr>

- 2차원 정수 좌표계에서 사각형 정보를 표현하는 방법을 src\ch03_1 프로젝트 파일에 구현 `주석 3-3-1`

<hr>

### 3.1.4 RotatedRect 클래스
- RotatedRect 클래스는 회전된 사각형을 표현하는 클래스
- RotatedRect 클래스는 회전된 사각형의 중심 좌표를 나타내는 center, 사각형의 가로 및 세로 크기를 나타내는 size, 회전 각도 정보를 나타내는 angle을 맴버 변수로 가짐
- 간략화한 RotatedRect 클래스 정의를 src\ch03-1 프로젝트 파일에 구현 `주석 3-4`

<hr>

- RotatedRect 클래스는 Point_, Size_, Rect_ 클래스와 달리 템플릿 클래스가 아니며, 모든 정보를 float 자료형을 사용하여 표현
- 즉, 중심점 좌표는 Point2f 클래스를 사용하고, 크기 정보는 Size2f 클래스를 사용
- 회전 각도는 float 자료형을 사용

<hr>

- RotatedRect 클래스를 사용하는 코드 작성 방법을 src\ch03_1 프로젝트 파일에 구현 `주석 3-4-1`

<hr>

### 3.1.5 Range 클래스
- Range 클래스는 범위 또는 구간을 표현하는 클래스
- Range 클래스는 범위의 시작과 끝을 나타내는 start와 end 맴버 변수를 가지고 있음
- 간략화한 Range 클래스 정의를 src\ch03-1 프로젝트 파일에 구현 `주석 3-5`

<hr>

### 3.1.6 String 클래스
- 많은 C/C++ 프로그램이 그러하듯이 OpenCV에서도 문자열을 다루는 경우가 많음
- OpenCV에서는 영상 출력 창에 고유의 문자열을 지정하여 구분하고, 영상에 문자열을 출력하는 기능도 제공
- C++ 표준 라이브러리(STL)에서 std::string 클래스를 이용하여 문자열을 저장하고 처리하듯이 OpenCV에서는 cv::string 클래스를 사용하여 문자열을 저장하고 처리할 수 있음

<hr>

- 원래 OpenCV 라이브러리에서는 자체적인 String 클래스를 정의하여 사용했음
- String 클래스는 std::string 클래스와 완전히 호환되도록 설계되어 있어서 std::string 클래스를 다루는 방식과 유사하게 사용할 수 있었음
- 그러다가 OpenCV 4.0 버전부터는 자체적인 String 클래스 정의를 삭제하고, 대신 C++ 표준 라이브러리의 std::string 클래스를 String 클래스로 이름 재정의함
- 실제로 OpenCV 헤더 파일에는 다음과 같이 이름 재정의 코드가 들어가 있음
  
```typedef std::string String```
  
- 결국 OpenCV 4.0 버전부터 std::string 클래스와 String 클래스는 완전히 같은 클래스
- 다만 코드 호환성을 위하여 여전히 OpenCV 코드에서는 std::string 대신 String 클래스 이름을 사용

<hr>

- String 클래스를 사용하는 방법을 src\ch03_1 프로젝트 파일에 구현 `주석 3-6`

<hr>

- 만약 특정한 형식의 문자열을 만들고 싶다면 OpenCV에서 제공하는 format() 함수를 사용할 수 있음
- format() 함수 원형은 다음과 같음
> `String format(const char* fmt, ...);
> - fmt : 형식 문자열
> - ... : 가변 인자
> - 반환값 : 지정한 형식으로 생성된 문자열

- format() 함수는 가변 인자 함수로 정의되어 있으며 사용법은 C 언어의 printf() 함수와 유사
- 즉, C 언어에서 printf() 함수를 사용하듯이 함수의 인자를 설정하면 그에 해당하는 출력 문자열이 String 객체 형태로 반환
- 예를 들어 OpenCV 예제 프로그램에서 test01.bmp, test02.bmp, test03.bmp 세 개의 테스트 파일을 불러오고 싶을 때, 다음과 같은 코드를 이용하여 파일 이름에 해당하는 문자열을 생성할 수 있음
``` C++
Mat imgs[3];
for (int i = 0; i < 3; i++) {
    String filename = format("test%02d.bmp", i + 1);
    imgs[i] = imread(filename);
}
```

<hr>

## 3.2 Mat 클래스

### 3.2.1 Mat 클래스 개요

- OpenCV 라이브러리에서 가장 많이 사용하는 클래스는 단연 행렬을 표현하는 Mat 클래스
- Mat 클래스는 일반적인 2차원 행렬 뿐만 아니라 고차원 행렬을 표현할 수 있으며, 한 개 이상의 채널(channel)을 가질 수 있음
- Mat 클래스에는 정수, 실수, 복소수 등으로 구성된 행렬 또는 벡터(vector)를 저장할 수 있고, 그레이스케일 또는 컬러 영상을 저장할 수도 있음
- 경우에 따라서는 벡터 필드(vector field), 포인트 클라우드(point cloud), 텐서(tensor), 히스토그램(histogram) 등 정보를 저장하는 용도로 사용됨
- 그러나 실제적으로는 2차원 영상 데이터를 저장하고 처리하는 용도로 가장 많이 사용되고 있음

<hr>

- Mat 클래스는 <OPENCV_SRC>\modules\core\include\opencv2\core\mat.hpp 파일에 정의되어 있음
   - 여기서 <OPENCV_SRC>는 OpenCV 소스 코드가 있는 폴더 위치를 의미
- Mat 클래스 전체 정의에서 중요한 부분만 선별하여 간략화한 코드 예시를 src\ch03_2 프로젝트 파일에 구현 `주석 3-6`

<hr>

- OpenCV에서 Mat 행렬은 다양한 자료형의 원소를 가질 수 있음
- 또한 Mat 클래스의 원소는 하나의 값을 가질 수 있고, 또는 여러 개의 값이 모여서 하나의 원소로 표현되기도 함
- OpenCV는 C/C++ 기본 자료형 중에서 unsigned char, signed char, unsigned short, signed short, int, float, double 자료형을 사용하는 Mat 행렬을 지원
- OpenCV 4.0부터는 16비트 실수형 자료형도 사용할 수 있음
- Mat 클래스에서 행렬이 어떤 자료형을 사용하는지에 대한 정보를 깊이(depth)라고 부름
- OpenCV에서 Mat 행렬의 깊이는 다음과 같은 형식의 매크로 상수를 이용하여 표현
`CV_<bit-depth>{U|S|F}`
- 깊이 표현 매크로 상수 형식의 처음에 나타나는 CV_는 OpenCV를 나타내는 접두사와 같은 역할
- 그 뒤의 <bit-depth>에는 8, 16, 32, 64의 숫자를 지정할 수 있으며, 이는 원소 값 하나의 비트 수를 나타냄
- 그 다음 {U|S|F} 부분에는 U, S, F 세 문자 중 하나를 지정할 수 있음
- 여기서 U는 부호 없는 정수형, S는 부호 있는 정수형, F는 부동 소수형을 의미
- 실제로 OpenCV 라이브러리는 행렬의 깊이 표현을 위해 다음과 같은 매크로 상수를 정의하여 사용
  
``` C++
#define CV_8U   0      // uchar, unsigned char
#define CV_8S   1      // schar, singned char
#define CV_16U  2      // ushort, unsigned short
#define CV_16S  3      // signed short
#define CV_32S  4      // int
#define CV_32F  5      // float
#define CV_64S  6      // double
#define CV_16F  7      // float16_t
```
  
- 앞에 나열된 매크로 정의에서 오른편 주석 부분은 각각의 깊이 표현 매크로 상수와 대응되는 C/C++ 자료형을 나타냄
   - 예를 들어 Mat 행렬의 깊이가 CV_8U라는 것은 이 행렬의 원소가 unsigned char 자료형을 사용한다는 의미
   - 만약 행렬 원소를 float 자료형으로 표현하려면 깊이가 CV_32F인 행렬을 사용해야 함

<hr>

- Mat 행렬 원소는 하나의 값을 가질 수도 있고, 또는 여러 개로 구성된 값을 가질 수도 있음
- Mat 행렬 원소를 구성하는 각각의 값을 채널(channel)이라고 부름
- 즉, Mat 행렬은 하나의 채널을 가질 수도 있고, 여러 개의 채널을 가질 수도 있음
- 이때 하나의 행렬을 구성하는 각 채널은 모두 같은 자료형을 사용해야 함
- 예를 들어 그레이스케일 영상은 하나의 픽셀이 밝기 정보 하나만 사용하므로 1채널 행렬로 표현
- 반면에 트루컬러 영상은 픽셀이 파란색(B), 녹색(G), 빨간색(R) 세 개의 색상 정보를 가지고 있으므로 3채널 행렬로 표현
- OpenCV에서는 Mat 행렬의 깊이 정보와 채널 수 정보를 합쳐서 Mat 객체의 타입(type)이라고 부름 
- OpenCV 행렬의 타입은 다음과 같은 형식의 매크로 상수로 표현
`CV_<bit-depth>{U|S|F}C(<number_of_channels>)`
- 즉, Mat 행렬의 깊이 표현 매크로 뒤에 C1, C3 같은 채널 정보가 추가로 붙어 있는 형태
- 예를 들어 CV_8UC1 타입은 8비트 unsigned char 자료형을 사용하고 채널이 한 개인 행렬 또는 영상을 의미
- B, G, R 세 개의 색상 성분을 가지고 있는 컬러 영상은 unsigned char 자료형을 사용하고 세 개의 채널을 가지고 있기 때문에 CV_8UC3 타입
- 복소수처럼 두 개의 실수 값을 사용하는 행렬은 CV_32FC2 타입으로 만들 수 있음
- OpenCV에서 새로운 행렬을 생성할 때에는 행렬의 타입 정보를 명시적으로 지정해야 함

> - OpenCV는 C/C++에서 사용하는 기본 자료형의 이름을 typedef 구문을 이용하여 새롭게 정의하여 사용
>    - 예를 들어 OpenCV에서 uchar 자료형은 unsigned char를 재정의한 이름
> - 이처럼 C/C++ 기본 자료형에 새로운 이름을 부여하는 것은 키보드로 타이핑하기 쉽게 하려는 이유도 있지만 OpenCV 라이브러리를 다양한 운영 체제에서 통일성 있게 활용하기 위한 목적도 있음
> > **OpenCV에서 주로 사용하는 자료형과 그 의미**
> > - schar : 부호 있는 1바이트 정수
> > - uchar : 부호 없는 1바이트 정수
> > - short : 부호 있는 2바이트 정수 (C/C++ 기본 자료형)
> > - ushort : 부호 없는 2바이트 정수
> > - int : 부호 있는 4바이트 정수 (C/C++ 기본 자료형)
> > - uint : 부호 없는 4바이트 정수
> > - int64 : 부호 있는 8바이트 정수
> > - uint64 : 부호 없는 8바이트 정수
> > - float16_t : (부호 있는) 2바이트 실수
> > - float : (부호 있는) 4바이트 실수 (C/C++ 기본 자료형)
> > - double : (부호 있는) 8바이트 실수 (C/C++ 기본 자료형)
  
### 3.2.2 행렬의 생성과 초기화

- 가장 기본적인 Mat 객체 생성 방법은 Mat 클래스의 기본 생성자를 이용하는 방법
- 기본 생성자는 아무런 인자를 받지 않으며 실제 코드를 작성할 때는 Mat 클래스 타입의 변수를 선언하는 형태

``` C++
Mat img1;
```

- 이렇게 생성된 img1 객체는 비어 있는 행렬
- 즉, img1.rows와 img1.cols 값은 0이고, img1.data에도 0(NULL)이 저장됨
- 이러한 비어 있는 행렬을 OpenCV 영상 처리 함수의 입력으로 사용하거나 또는 비어 있는 행렬의 원소 값을 참조하려고 하면 에러가 발생하므로 주의해야 함

<hr>

- Mat 객체를 생성함과 동시에 원소 값 저장을 위한 메모리 공간을 할당하려면 다음 생성자를 사용

> ``` C++
> Mat::Mat(int rows, int cols, int type);
> ``` 
> - rows : 새로 만들 행렬의 행 개수(영상의 세로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 가로 크기)
> - type : 새로 만들 행렬의 타입

- 이 생성자는 행 개수가 rows이고, 열 개수가 cols인 2차원 행렬(또는 영상)을 생성
- 이 생성자의 세 번째 인자 type에는 Mat 객체의 타입을 나타내는 매크로 상수를 전달
- 이 생성자를 이용하여 가로 크기가 640이고, 세로 크기가 480인 영상을 생성하려면 다음과 같은 형태로 코드를 작성

``` C++
Mat img2(480, 640, CV_8UC1); // unsigned char, 1-channel
Mat img3(480, 640, CV_8UC3); // unsigned char, 3-channels
```
  
- Mat 클래스 생성자에 영상의 크기 정보를 지정할 때 가로 크기, 세로 크기 순서가 아니라 세로 크기, 가로 크기 순서인 점을 주의
- 앞 코드에서 img2와 img3는 서로 크기는 같지만 타입이 다른 영상
- img2 객체는 unsigned char 자료형을 사용하고 한 개의 채널이 있는 영상을 표현
- img3 객체는 타입이 CV_8UC3이므로 unsigned char 자료형을 사용하고 세 개의 채널이 있는 영상
- 보통 CV_8UC1 타입은 그레이스케일 영상에서 사용하고, CV_8UC3 타입은 트루컬러 영상에 사용

<hr>

- Mat 클래스 생성자에서 행렬의 크기를 지정할 때 Size 클래스를 사용할 수도 있음
  
> ``` C++
> Mat::Mat(Size size, int type);
> ```
> - size : 새로 만들 행렬의 크기, Size(cols, rows) 또는 Size(width, height)
> - type : 새로 만들 행렬의 타입

- 여기서 사용된 Size 클래스는 2차원 사각형(또는 영상, 행렬)의 가로, 세로 크기를 표현하기 위해 사용하는 OpenCV 클래스
- Size 클래스의 생성자는 보통 두 개의 인자를 받으며, 가로 크기와 세로 크기 순서로 값을 지정
- 그러므로 가로 크기가 640, 세로 크기가 480인 3채널 컬러 영상을 생성하려면 다음과 같이 코드를 작성

> ``` C++
> Mat img4(Size(640, 480), CV_8UC3);  // Size(width, height)
> ```
  
<hr>

- 행렬의 크기와 타입을 지정하여 Mat 객체를 생성할 경우, Mat 행렬의 모든 원소는 흔히 쓰레기 값(garbage value)이라고 부르는 임의의 값으로 채워지게 됨
- 그러므로 Mat 객체를 생성함과 동시에 모든 원소 값을 특정 값으로 초기화하여 사용하는 것이 안전
- 정해진 크기와 타입의 Mat 객체를 생성하고 모든 원소 값을 초기화하려면 다음 형태의 생성자를 사용

> ``` C++
> Mat::Mat(int rows, int cols, int type, const Scalar& s);
> Mat::Mat(Size size, int type, const Scalar& s)
> ```
> - rows : 새로 만들 행렬의 행 개수(영상의 세로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 가로 크기)
> - size : 새로 만들 행렬의 크기
> - type : 새로 만들 행렬의 타입
> - s : 행렬 원소 초깃값

- 이 생성자들은 행렬의 크기와 타입을 지정하는 생성자에 원소의 초깃값을 설정하는 인자 s가 추가되어 있음
- 초깃값 s의 타입으로 사용된 Scalar 클래스는 네 개의 실수 값을 저장할 수 있는 OpenCV 클래스이며, 주로 영상의 픽셀 값을 표현하는 용도로 사용됨
- Scalar 클래스가 그레이스케일 영상의 픽셀 값을 표현할 때에는 하나의 맴버 변수만을 사용하고, 3채널 컬러 영상의 픽셀 값을 표현할 때에는 세 개의 맴버 변수를 사용
- 예를 들어 모든 픽셀 값이 128로 초기화된 그레이스케일 영상과 모든 픽셀이 빨간색으로 설정된 컬러 영상을 생성하려면 다음과 같이 코드를 작성

``` C++
Mat img5(480, 640, CV_8UC1, Scalar(128));         // initial values, 128
Mat img6(480, 640, CV_8UC3, Scalar(0, 0, 255));   // initial values, red
```

- 위 코드에서 그레이스케일 영상 img5는 모든 픽셀 밝기가 128로 설정됨
- 그리고 컬러 영상 img6에 대해서는 초깃값으로 Scalar(0, 0, 255)를 지정하였으며, 이는 순수한 빨간색을 나타냄
- Scalar 클래스를 이용하여 컬러 영상의 색상을 지정할 때에는 파란색(B), 녹색(G), 빨간색(R) 색상 성분 순서로 값을 지정

<hr>

- 새로운 행렬을 생성할 때 모든 원소 값을 0으로 초기화하는 경우가 많으며, 이러한 경우 Mat 클래스의 행렬 원소 초깃값에 Scalar(0)을 지정하면 됨
- 그런데 이처럼 행렬 원소가 0으로 초기화된 행렬을 생성하는 경우가 많기 때문에 OpenCV는 이러한 용도의 함수를 별도로 제공
- OpenCV에서 모든 원소가 0으로 초기화된 행렬을 만드는 함수 이름은 Mat::zeros()

> ``` C++
> static MatExpr Mat::zeros(int rows, int cols, int type)
> static MatExpr Mat::zeros(Size size, int type);
> ```
> - rows : 새로 만들 행렬의 행 개수(영상의 세로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 가로 크기)
> - size : 새로 만들 행렬의 크기
> - type : 새로 만들 행렬의 타입
> - 반환값 : 모든 원소가 0으로 초기화된 행렬 표현식

- Mat::zeros() 함수는 새로 생성할 행렬의 크기와 타입 정보를 인자로 받음
- Mat::zeros() 함수는 Mat 클래스의 정적 맴버 함수이기 때문에 실제 코드에서 사용할 때 Mat::을 붙여서 사용해야 함
- Mat::zeros() 함수의 반환형인 MatExpr은 OpenCV에서 행렬의 대수 연산을 표현하는 클래스이며, 자동으로 Mat 클래스로 형 변환됨
- 그러므로 Mat::zeros()의 반환값은 Mat 타입의 변수에 할당할 수 있음
- 예를 들어 0으로 초기화된 3×3 정수형 행렬을 생성하려면 다음과 같이 코드를 작성
  
```
Mat mat1 = Mat::zeros(3, 3, CV_32SC1);
```

- 행렬의 모든 원소가 1로 초기화된 행렬을 생성하려면 Mat::ones() 함수를 사용할 수 있음
- 또한 행령 연산에서 자주 사용되는 단위 행렬(identify matrix) 함수를 생성하려면 Mat::eyes() 함수를 사용할 수 있음
- Mat::ones()와 Mat::eyes() 함수 원형은 다음과 같음

> ``` C++
> static MatExpr Mat::ones(int rows, int cols, int type);
> static MatExpr Mat::ones(Size size, int type);
> ```
> - rows : 새로 만들 행렬의 행 기수(영상의 가로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 세로 크기)
> - size : 새로 만들 행렬의 크기
> - type : 새로 만들 행렬의 타입
> - 반환값 : 모든 원소가 1로 초기화된 행렬 표현식
  
> ``` C++
> static MatExpr Mat::eye(int rows, int cols, int type);
> static MatExpr Mat::eye(Size size, int type);
> ```
> - rows : 새로 만들 행렬의 행 개수(영상의 세로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 가로 크기)
> - size : 새로 만들 행렬의 크기
> - type : 새로 만들 행렬의 타입
> - 반환값 : 단위 행렬을 표현하는 행렬 표현식
  
- Mat::ones와 Mat::eye() 함수의 사용 방법은 Mat::zeros 함수와 완전히 같으며, 생성되는 행렬 원소의 초깃값만 다름
- 다음은 Mat::ones()와 Mat::eye() 함수를 사용하여 Mat 객체를 생성하는 예제 코드

``` C++
Mat mat2 = Mat::ones(3, 3, CV_32FC1);   // 1's matrix
Mat mat3 = Mat::eye(3, 3, CV_32FC1);    // identify matrix
```

- 위 예제 코드에서 mat2와 mat3는 모두 3×3 크기의 행렬이고, 행렬 원소는 float 자료형을 사용
- 앞에서 생성된 행렬 mat1, mat2, mat3을 행렬 수식으로 표현하면 다음과 같음

$$
mat1 = 
 \begin{bmatrix}
  0 & 0 & 0 \\
  0 & 0 & 0 \\
  0 & 0 & 0  \\
 \end{bmatrix},
mat2 = 
 \begin{bmatrix}
  1 & 1 & 1 \\
  1 & 1 & 1 \\
  1 & 1 & 1  \\
 \end{bmatrix},
mat3 = 
 \begin{bmatrix}
  1 & 0 & 0 \\
  0 & 1 & 0 \\
  0 & 0 & 1  \\
 \end{bmatrix}
$$

<hr>

- Mat 객체를 생성할 때, 행렬 원소를 저장할 메모리 공간을 새로 할당하는 것이 아니라 기존에 이미 할당되어 있는 메모리 공간의 데이터를 행렬 원소 값으로 사용할 수 있음
- 외부 메모리 공간을 활용하여 Mat 객체를 생성한다는 것은 자체적인 메모리 할당을 수행하지 않고 외부 메모리를 참조하는 방식이기 때문에 객체 생성이 빠르다는 장점이 있음
- 이러한 용도의 Mat 클래스 생성자 형식은 다음과 같음

> ``` C++
> Mat::Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);
> Mat::Mat(Size size, int type, void* data, size_t step=AUTO_STEP);
> ```
> - rows : 새로 만들 행렬의 행 개수(영상의 세로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 가로 크기)
> - size : 새로 만들 행렬의 크기
> - type : 새로 만들 행렬의 타입
> - data : 사용할 (외부) 행렬 데이터의 주소, 외부 데이터를 사용하여 Mat 객체를 생성할 경우, 생성자에서 원소 데이터 저장을 위한 메모리 공간을 동적으로 할당하지 않음
> - step : (외부) 행렬 데이터에서 한 행이 차지하는 바이트 수, 만약 외부 행렬 데이터의 각 행에 여분의 패딩 바이트(padding byte)가 존재한다면 명시적으로 지정해야 함. 만약 기본값 AUTO_STEP을 사용하면 패딩 바이트가 없다고 간주
  
- 아래 코드는 여섯 개의 원소를 갖는 float 자료형의 배열 data를 먼저 정의하고, 이 배열을 행렬 원소로 사용하는 Mat 객체 mat4를 생성

``` C++
float data[] = {1, 2, 3, 4, 5, 6};
Mat mat4(2, 3, CV_32FC1, data);
```

- 이처럼 외부 배열을 행렬 원소 값으로 사용하고자 할 경우, 외부 배열 크기와 생성한 배열 원소 개수는 같아야 하고 서로 사용하는 자료형도 같아야 함
- 앞 코드에서 data 배열은 여섯 개의 원소를 가지고 있고, mat4 행렬도 2행 3열이므로 원소가 여섯 개
- 또한 data와 mat4는 모두 float 자료형을 사용
- 위와 같이 코드를 작성할 경우 mat4 행렬의 1행은 data 배열의 처음 세 개의 원소로 채워지고, 2행은 data 배열의 나머지 세 원소로 채워짐
- 결국 위 코드에 의해 생성되는 mat4행렬은 다음과 같은 형태를 가짐

$
mat4 = 
 \begin{bmatrix}
  1 & 2 & 3 \\
  4 & 5 & 6 \\
 \end{bmatrix}
$

- 이처럼 외부 메모리 공간을 참조하여 Mat 객체를 생성할 경우, Mat 객체의 원소 값과 외부 메모리 공간의 데이터 값이 상호 공유됨
  - 즉, mat4 객체를 생성한 후 외부 메모리 공간의 값을 변경하면 mat4 행렬의 원소 값도 같이 변경됨
  - 반대로 mat4 행렬의 원소 값을 변경하면 외부 메모리 공간의 값도 변경됨
- 동적 할당하며 만든 대용량 메모리도 Mat 클래스에서 참조하여 사용할 수 있음
  - 다만 동적 할당된 메모리는 Mat 객체가 소멸될 때 자동으로 해제되지 않으므로 반드시 사용자가 직접 메모리를 해제해야 함

<hr>

- 사용자가 지정한 원소 값을 이용하여 Mat 객체를 생성하는 방법 중에 Mat_ 클래스를 사용하는 방법도 종종 사용됨
- Mat_ 클래스는 Mat 클래스를 상속하여 만든 템플릿 클래스로서 Mat_ 클래스와 Mat 객체는 상호 변환이 가능
- 그런데 Mat_ 클래스는 << 연산자와 콤마(,)를 이용하여 간단하게 행렬 원소 값을 설정하는 인터페이스를 제공
- 그래서 일단 Mat_ 객체를 만들어서 << 연산자로 행렬 원소를 지정한 후, 이를 Mat 객체로 변환하여 사용하기도 함
- 아래는 실제 Mat_ 클래스를 사용하는 예제 코드

``` C++
Mat_<float> mat5_(2, 3);
mat5_ << 1, 2, 3, 4, 5, 6;
Mat mat5 = mat5_;
```

- 위 예제 코드의 첫 번째 행에서 변수 mat5_는 float 자료형을 사용하는 2×3 행렬
  - Mat_ 클래스는 템플릿 클래스로 정의되어 있어서 저장할 원소의 자료형을 명시적으로 지정해야 함
- 두 번째 행에서는 << 연산자와 콤마(,)를 이용하여 mat_ 행렬의 전체 여섯 개의 원소 값을 차례대로 지정
- 그리고 세 번째 행에서는 mat5_ 행렬을 복사하여 Mat 클래스 타입의 변수 mat5를 선언
- 그 결과 mat5 행렬은 2×3 크기를 갖고, 타입은 CV_32FC1이며 mat5_ 행렬과 원소를 공유
- 이후 mat5_ 변수를 사용하지 않는다면 위에서 세 줄로 쓴 코드는 다음과 같이 한 줄로 간략하게 사용할 수 있음

``` C++
Mat mat5 = (Mat_<float>(2, 3) << 1, 2, 3, 4, 5, 6);
```

- 이렇게 생성된 mat5는 다음과 같은 형태의 행렬

$
mat5 = 
 \begin{bmatrix}
  1 & 2 & 3 \\
  4 & 5 & 6 \\
 \end{bmatrix}
$

<br>

- OpenCV 4.0에서는 C++11의 초기화 리스트(initializer list)를 이용한 행렬 초기화 방법을 사용할 수 있음
- Mat 클래스 또는 Mat_ 클래스의 생성자에 행렬 크기와 초깃값을 중괄호를 이용한 리스트 형태로 전달하는 방식
- 다만 생성된 Mat 객체의 타입을 명시적으로 지정하기 위해 Mat_ 클래스 형식으로 생성한 후 Mat 타입으로 변경하는 것이 좋음
- 다음은 앞서 설명한 mat5 행렬과 같은 초깃값을 갖는 행렬 mat6을 초기화 리스트 방법으로 생성하는 예제 코드

``` C++
Mat mat6 = Mat_<float>({2, 3}, { 1, 2, 3, 4, 5, 6 });
```
  
<hr>

- 비어 있는 Mat 객체 또는 이미 생성된 Mat 객체에 새로운 행렬을 할당하려면 Mat 클래스의 Mat::create() 맴버 함수를 사용할 수 있음
- Mat::create() 맴버 함수의 원형은 다음과 같음

> ``` C++
> void Mat::create(int rows, int cols, int type);
> void Mat::create(Size size, int type);
> ```
> - rows : 새로 만들 행렬의 행 개수(영상의 세로 크기)
> - cols : 새로 만들 행렬의 열 개수(영상의 가로 크기)
> - size : 새로 만들 행렬의 크기
> - type : 새로 만들 행렬의 타입
  
- 이미 행렬 데이터가 할당되어 있는 Mat 객체에서 Mat::create() 함수를 호출할 경우, 만약 Mat::create() 함수의 인자로 지정한 행렬 크기와 타입이 기존 행렬과 모두 같으면 Mat::create() 함수는 별다른 동작을 하지 않고 그대로 함수를 종료
- 반면에 새로 만들 행렬의 크기 또는 타입이 기존 행렬과 다른 경우, Mat::create() 함수는 일단 기존 메모리 공간을 해제한 후 새로운 행렬 데이터 저장을 위한 메모리 공간을 할당
- 예를 들어 이미 생성되어 있는 Mat 클래스 타입의 변수 mat4와 mat5에 새로운 크기와 타입의 행렬을 할당하려면 다음과 같이 코드를 작성

```
mat4.create(256, 256, CV_8UC3); // 256×256, uchar, 3-channels
mat5.create(4, 4, CV_32FC1); // 4×4, float, 1-channel
```
  
- Mat::create() 함수는 새로 만든 행렬의 원소 값을 초기화하는 기능이 없음
- 그러므로 Mat::create() 함수를 이용하여 행렬을 생성한 후 행렬 전체 원소 값을 초기화하고 싶다면 OpenCV에서 제공하는 별도의 함수를 이용해야 함

<hr>

- Mat 클래스는 = 연산자 재정의 또는 Mat::setTo() 맴버 함수를 이용하여 행렬 전체 원소 값을 한꺼번에 설정할 수 있음
- Mat 행렬의 전체 원소 값 설정을 위한 = 연산자 재정의와 Mat::setTo() 함수의 원형은 다음과 같음

> ``` C++
> Mat& Mat::operator = (const Scalar& s);
> ```
> - s : 행렬 원소에 설정할 값
> - 반환값 : 값이 설정된 Mat 객체의 참조
  
> ``` C++
> Mat& Mat::setTo(InputArray value, InputArray mask = noArray());
> ```
> - value : 행렬 원소에 설정할 값
> - mask : 마스크 행렬. 마스크 행렬의 원소가 0이 아닌 위치에서만 value 값이 설정됨. 행렬 전체 원소 값을 설정하려면 noArray() 또는 Mat()을 지정
> - 반환값 : Mat 객체의 참조

- Mat::setTo() 함수는 두 개의 인자를 가지고 있지만 두 번째 인자 mask는 기본값을 가지고 있으므로 생략할 수 있음
- mask 인자를 생략하거나 mask 인자에 NoArray() 또는 Mat()을 지정하면 행렬 전체 원소를 value 값으로 설정
- mask 인자는 영상의 특정 영역에 대해서만 원소 값을 설정하고 싶을 때 사용할 수 있음
- Mat::create() 함수를 이용하여 생성한 행렬 mat4와 mat5 행렬의 모든 원소 값을 일괄적으로 설정하는 예제 코드는 아래와 같음
  
``` C++
mat4 = Scalar(255, 0, 0);
mat5.setTo(1.f);
```
  
- 위 코드는 mat4 영상의 모든 픽셀을 파란색에 해당하는 Scalar(255, 0, 0)으로 설정하고, 행렬 mat5의 모든 원소 값은 1.f로 설정

<hr>

- 상단에 명시한 다양한 Mat 행렬 생성과 원소 값 초기화 예제 코드를 src\ch03_2 프로젝트 파일에 구현 `주석 3-7`

> - Mat 클래스는 3차원 이상의 다차원 행렬도 지원
> - 3차원 이상의 행렬을 생성할 경우에는 다음과 같은 형태의 생성자를 사용할 수 있음
> ``` C++
> Mat::Mat(int ndims, const int* sizes, int type);
> Mat::Mat(const std::vector<int>& sizes, int type);
> ```
> - 그러나 실제적으로는 3차원 이상의 Mat 행렬을 직접 만들어서 사용하는 경우는 거의 없음

<hr>

### 3.2.3 행렬의 복사

- 먼저 강아지 사진이 담겨 있는 dog.bmp 파일을 불러와서 Mat 타입의 변수 img1에 저장하고, 이를 이용하여 다양한 예제 코드를 작성
  
``` C++
Mat img1 = imread("dog.bmp");
```

- Mat 클래스 객체에 저장된 영상 또는 행렬을 복사하는 가장 간단한 방법은 복사 생성자 또는 대입 연산자를 사용하는 방법
- 먼저 Mat 클래스 복사 생성자를 이용하여 img1 변수에 저장된 강아지 영상을 복사하여 img2 영상을 생성하려면 아래와 같이 코드를 작성

``` C++
Mat img2 = img1;      // 복사 생성자(얕은 복사)
```

- 위 코드는 img1과 같은 크기, 같은 타입의 새로운 Mat 객체 img2를 생성하고 img1의 픽셀 데이터를 img2가 참조하도록 설정
  - 즉, img1과 img2는 하나의 영상을 공유하는 서로 다른 이름의 변수 형태로 동작
- 이처럼 Mat 클래스의 복사 생성자는 행렬의 원소 데이터를 공유하는 얕은 복사(shallow copy)를 수행

<hr>

- Mat 클래스의 대입 연산자도 복사 생성자와 마찬가지로 얕은 복사를 수행
- 대입 연산자를 이용하여 img1 영상을 새로운 변수 img3에 복사하려면 다음과 같이 코드를 작성

``` C++
Mat img3;
img3 = img1;      // 대입 연산자(얕은 복사)
```

<hr>

- 만약 복사본 영상을 새로 생성할 때, 픽셀 데이터를 공유하는 것이 아니라 메모리 공간을 새로 할당하여 픽셀 데이터 전체를 복사하고 싶다면 Mat::clone() 또는 Mat::copyTo() 함수를 사용해야 함
- Mat::clone() 함수와 Mat::copyTo() 함수의 원형은 다음과 같음

> ``` C++
> Mat Mat::clone() const;
> ```
> - 반환값 : *this 행렬의 복사본
  
> ``` C++
> void Mat::copyTo(OutputArray m) const;
> void Mat::copyTo(OutputArray m, InputArray mask) const;
> ```
> - m : 복사본이 저장될 행렬, 만약 *this 행렬과 크기 및 타입이 다르면 메모리를 새로 할당한 후 픽셀 값을 복사
> - mask : 마스크 행렬. 마스크 행렬의 원소 값이 0이 아닌 좌표에서만 행렬 원소를 복사
  
- Mat::clone() 함수는 자기 자신과 동일한 Mat 객체를 완전히 새로 만들어서 반환
- Mat::copyTo() 함수는 인자로 전달된 m 행렬에 자기 자신을 복사
  - 만약 Mat::copyTo() 함수를 호출한 행렬과 인자로 전달된 행렬 m이 서로 크기와 타입이 같으면 원소 값 복사만 수행
  - 반면에 서로 크기 또는 타입이 다르면 Mat::copyTo() 함수 내부에서 행렬 m을 새로 생성한 후 픽셀 값을 복사
- dog.bmp 강아지 영상을 저장하고 있던 img1 영상을 Mat::clone()과 Mat::copyTo() 함수를 이용하여 새로운 영상에 복사하려면 다음과 같이 코드를 작성

``` C++
Mat img4 = img1.clone();      // 깊은 복사

Mat img5;
img1.copyTo(img5);            // 깊은 복사
```

- 위 코드에서 img4는 img.clone() 함수에 의해 반환되는 행렬 객체를 저장
- 변수 img5는 일단 비어 있는 행렬 객체로 생성되고, 이후 Mat::copyTo() 함수에 의해 img1 객체에 저장된 영상이 img5 객체로 복사됨
- 결국 img4와 img5는 각각 픽셀 데이터를 저장할 메모리 공간을 따로 가지고 있고, img1에 저장된 강아지 영상의 복사본을 저장
- Mat::clone()과 Mat::copyTo() 함수처럼 완전히 메모리 공간을 새로 할당하여 픽셀 값을 복사하는 형태의 복사를 깊은 복사(deep copy)라고 함

<hr>

- 복사 생성자 또는 대입 연산자를 이용하는 행렬의 얕은 복사와 Mat::clone() 또는 Mat::copyTo() 함수를 이용한 행렬의 깊은 복사를 수행하는 예제 코드를 src\ch03_02 프로젝트 파일에 구현 `주석 3-8`

<hr>

### 3.2.4 부분 행렬 추출

- Mat 클래스에 저장된 영상에서 특정 사각형 영역의 부분 행렬을 추출하고 싶을 때에는 Mat 클래스에 정의된 괄호 연산자 재정의를 사용
- 주로 사용되는 Mat 클래스 괄호 연산자 재정의 함수 원형은 다음과 같음

> ``` C++
> Mat Mat::operator()(const Rect& roi) const;
> Mat Mat::operator()(const Range rowRange, Range colRange) const;
> ```
> - roi : 사각형 관심 영역
> - rowRange : 관심 행 범위
> - colRange : 관심 열 범위
> - 반환값 : 추출한 부분 행렬 또는 영상. 부분 영상의 픽셀 데이터를 서로 공유
  
- 아래 예제 코드는 cat.bmp 파일에 저장된 고양이 영상을 불러와서 고양이 얼굴 주변의 부분 영상을 추출하는 예제 코드
  
``` C++
Mat img1 = imread("cat.bmp");
Mat img2 = img1(Rect(220, 120, 340, 240));
```
  
- 위 예제 코드의 첫 번쨰 행에서는 cat.bmp 고양이 영상을 3채널 컬러 영상 형태로 불러와서 img1 변수에 저장
- 두 번째 행에서 img1 변수 이름 바로 뒤에 괄호를 붙여서 사용하였는데, 이 부분이 Mat 클래스의 괄호 연산자 재정의로 동작
-   즉, img1(Rect(220, 120, 340, 240)) 코드는 img1 영상의 (220, 120) 좌표부터 340×240 크기만큼의 사각형 부분 영상을 추출하는 코드이고, 추출한 부분 영상은 img2 변수에 저장
- img2 창에 나타난 부분 영상의 가로 크기는 340픽셀이고 세로 크기는 240픽셀

<hr>

- Mat 클래스의 괄호 연산자를 이용하여 얻은 부분 영상은 독립된 메모리 공간을 확보하여 복사하는 깊은 복사가 아니라, 픽셀 데이터를 공유하는 얕은 복사 형식
  - 그렇기 때문에 부분 영상을 추출한 후 부분 영상의 픽셀 값을 변경하면 추출한 부분 영상뿐만 아니라 원본 영상의 픽셀 값도 함께 변경됨
- 부분 영상 추출 시 픽셀 데이터를 공유한다는 특성을 이용하면 입력 영상의 일부분에만 특정한 영상 처리 수행 가능

<hr>

- 영상 반전은 밝은 픽셀을 어둡게 만들고, 어두운 픽셀은 밝게 변화시키는 밝기 변환 기법
- 3채널 컬러 영상의 경우에는 각각의 색상 성분에 반전을 수행
- 영상의 반전은 Mat 클래스 타입의 변수 앞에 ~ 연산자를 붙이는 방식으로 쉽게 적용 가능
- 앞서 구한 부분 영상 img2를 반전시키면 아래와 같이 코드를 작성
  
``` C++
img2 = ~img2;
```
  
- 위 코드는 img2 영상을 반전하여 그 결과를 다시 img2에 저장

<hr>

- Mat 클래스의 부분 영상 참조 기능은 입력 영상에 사각형 모양의 관심 영역(ROI, Region Of Interest)을 설정하는 용도로 사용할 수 있음
- ROI는 영상의 전체 영역 중에서 특정 영역에 대해서만 영상 처리를 수행할 때 설정하는 영역을 의미
- 사각형이 아닌 임의의 모양의 ROI를 설정하고 싶은 경우에는 마스크 연산을 응용할 수 있음

<hr>

- 만약 독립된 메모리 영역을 확보하여 부분 영상을 추출하고자 한다면 괄호 연산자 뒤에 Mat::clone() 함수를 함께 사용해야 함
- 즉, Mat 클래스의 괄호 연산자 재정의 함수를 사용한 후, 바로 뒤에 .clone() 코드를 붙여서 사용하면 독립된 복사본의 부분 영상을 만들 수 있음
- 아래는 실제 코드 사용 예
  
``` C++
Mat img3 = img1(Rect(220, 120, 340, 240)).clone();
```

- 위 처럼 코드를 작성하면 img1 영상과 img3 영상은 서로 다른 메모리 공간을 사용하며, 추후 img3 영상의 픽셀 값을 변경해도 img1 영상은 변경되지 않음

<hr>

- 영상의 부분 영상 관련 예제 코드를 src/ch03_2 프로젝트 파일에 구현 `주석 3-9`

<hr>

- Mat 행렬에서 특정 범위의 행 또는 열을 부분 행렬로 추출하고자 할 때에는 Mat::rowRange() 또는 Mat::colRange() 함수를 사용할 수 있음
- Mat::rowRange() 함수는 지정한 범위의 행으로 구성된 행렬을 반환하고, Mat::colRange() 함수는 지정한 범위의 열로 구성된 행렬을 반환
- 행 또는 열의 범위는 두 개의 int 값으로 지정할 수도 있고, 또는 Range 클래스 객체를 이용하여 지정할 수 있음
- Mat::rowRange()와 Mat::colRange() 함수 원형은 다음과 같음
  
> ``` C++
> Mat Mat::rowRange(int startrow, int endrow) const;
> Mat Mat::rowRange(const Range& r) const;
> ```
> - startrow : 추출할 행 범위 시작 번호(포함)
> - endrow : 추출할 행 범위 끝 번호(불포함)
> - r : 추출할 행 범위
> - 반환값 : 지정한 행 범위에 해당하는 행렬
  
> ``` C++
> Mat Mat::colRange(int startcol, int endcol) const;
> Mat Mat::colRange(const Range& r) const;
> ```
> - startcol : 추출할 열 범위 시작 번호(포함)
> - endcol : 추출할 열 범위 끝 번호(불포함)
> - r : 추출할 열 범위
> - 반환값 : 지정한 열 범위에 해당하는 행렬
  
<br>

- 만약 Mat 행렬로부터 하나의 행 또는 열을 추출하여 1행짜리 또는 1열짜리 행렬을 만들고자 할 때에는 Mat::row() 또는 Mat::col() 함수를 사용할 수 있음
- Mat::row()와 Mat::col() 함수 원형은 다음과 같음
  
> ``` C++
> Mat Mat::row(int y) const;
> Mat Mat::col(int x) const;
> ```
> - y : 부분 행렬로 추출할 행 번호
> - x : 부분 행렬로 추출할 열 번호
> - 반환값 : 추출한 부분 행렬(얕은 복사)
  
- Mat::rowRange(), Mat::colRange(), Mat::row(), Mat::col() 함수들은 모두 부분 행렬을 얕은 복사 형태로 반환
- 그러므로 메모리를 따로 할당하여 행렬 원소를 복사하는 깊은 복사를 수행하려면 Mat::clone() 함수와 함께 사용해야 함

<hr>

### 3.2.5 행렬의 원소 값 참조

#### Mat::at() 함수 사용 방법

- OpenCV에서 제공하는 가장 직관적인 행렬 원소 접근 방법은 Mat::at() 맴버 변수를 사용하는 방법
- Mat::at() 함수는 보통 행과 열을 나타내는 두 개의 정수를 인자로 받아 해당 위치의 행렬 원소 값을 참조 형식으로 반환
- Mat::at() 함수는 템플릿을 사용하는 템플릿 함수로서 여러 가지 형태로 재정의가 되어 있으며, 주로 사용하는 Mat::at() 함수 형식은 아래와 같음

> ``` C++
> template<typename _Tp> _Tp& Mat::at(int y, int x)
> ```
> - y : 참조할 행 번호
> - x : 참조할 열 번호
> - 반환값 : (_Tp& 타입으로 형 변환된) y번째 행, x번째 열의 원소 값(참조)
  
- Mat::at() 함수는 템플릿 함수로 정의되어 있기 때문에 Mat::at() 함수를 사용할 때에는 행렬 원소 자료형을 명시적으로 지정해야 함
  - 예를 들어 Mat 행렬의 타입이 CV_8UC1이면 uchar 자료형을 지정하고, CV_32FC1 타입의 행렬이라면 float 자료형을 지정해야 함
  - 만약 CV_8U3C 타입을 사용하는 3채널 컬러 영상이라면 OpenCV에서 정의한 Vec3b 자료형을 명시해서 사용
- Mat::at() 함수의 첫 번째 인자는 참조할 원소의 행 번호이고, 이는 (x, y) 좌표계에서 y 좌표에 해당
- Mat::at() 함수의 두 번째 인자에는 참조하려는 원소의 열 번호를 전달
- 그러므로 Mat 타입의 변수 img에 그레이스케일 영상이 저장되어 있을 경우, (x, y) 좌표 픽셀 값을 참조하려면 img.at<uchar>(y, x) 형태로 코드를 작성해야 함
- 만약 Mat::at() 함수로 전달된 인자의 좌표 (x, y)가 행렬 크기를 벗어날 경우에는 에러가 발생하므로 주의해야 함

<hr>

- 아래는 모든 원소 값이 0으로 초기화된 CV_8UC1 타입의 행렬 mat1을 정의하고, 이 행렬의 모든 원소 값을 1만큼 증가시키는 예제 코드
  
``` C++
Mat mat1 = Mat::zeros(3, 4, CV_8UC1);

for (int j = 0; j < mat1.rows; j++;) {
  for (int i = 0; i < mat1.cols; i++) {
    mat.at<uchar>(j, i)++;
  }
}
```

- 위 예제 코드에서 mat1은 0으로 초기화된 3×4 행렬이고, 각 원소는 uchar 자료형을 사용
  - 그러므로 Mat::at() 함수를 사용할 때 <> 괄호 안에 uchar 자료형을 명시
- 코드에서 바깥쪽 for 반복문은 행렬의 전체 행에 대한 반복이고, 변수 j는 각 행의 번호를 나타냄
- 그리고 안쪽 for 반복문은 j번째 행의 전체 열에 대한 반복이고, 변수 i는 각 열의 번호를 나타냄
- for 반복문 안에서는 Mat::at() 함수를 이용하여 j번째 행, i번째 열의 원소를 참조하고 그 값을 1만큼 증가시킴
- Mat::at() 함수가 행렬 원소를 참조로 반환하기 때문에 Mat::at() 함수의 반환값을 변경하면 mat1 행렬 원소 값도 함께 변경됨

<hr>

#### Mat::ptr() 함수 사용 방법
- Mat::ptr() 함수는 Mat 행렬에서 특정 행의 첫 번쨰 원소 주소를 반환
- Mat::ptr() 함수는 여러 가지 형식으로 재정의되어 있지만, 가장 널리 사용하는 Mat::ptr() 함수 형식은 아래와 같음

> ``` C++
> template<typename _Tp>
> _Tp* Mat::ptr(int y)
> ```
> - y : 참조할 행 번호
> - 반환값 : (_Tp* 타입으로 형 변환된) y번째 행의 시작 주소

- Mat::ptr() 함수는 인자로 전달된 y번째 행의 시작 주소를 반환
- Mat::ptr() 함수도 Mat::at() 함수와 마찬가지로 템플릿으로 정의되어 있기 때문에 Mat::ptr() 함수를 사용할 때 행렬 원소의 자료형을 명시적으로 지정해야 함
- Mat::ptr() 함수는 지정한 자료형의 포인터를 반환하며, 이 포인터를 이용하여 지정된 행의 원소에 접근 가능

<hr>

- 아래는 Mat::ptr() 함수를 이용하여 CV_8UC1 타입의 행렬 mat1 행렬의 모든 원소 값을 1씩 증가시키는 예제 코드
  
``` C++
for (int j = 0; j < mat.rows; j++;)  {
  uchar* p = mat1.ptr<uchar>(j);
  for (int i = 0; j < mat.cols; i++>) {
    p[i]++;
  }
}
```
  
- 위 코드에서 바깥쪽 for 반복문은 행렬의 전체 행에 대한 반복이고, 변수 j는 각 행의 번호를 나타냄
- 그러므로 mat1.ptr<uchar>(j) 코드는 j번째 행 원소의 시작 주소를 반환
- 이 주소를 포인터형 변수 p에 저장하면 이후 p를 1차원 배열처럼 사용하여 해당 행의 원소에 접근할 수 있음
  - 즉, j번째 행의 0번째 열 원소는 p[0]이고, 1번째 열 원소는 p[1]
  - j번째 행의 맨 마지막 열에 해당하는 원소는 p[mat1.cols - 1] 형식으로 접근할 수 있음
- Mat::ptr() 함수를 통해 얻은 행의 시작 주소를 이용하여 각 행의 모든 픽셀을 1차원 배열처럼 접근할 경우, 행렬의 가로 크기를 벗어나는 위치에 접근하지 않도록 주의해야 함

<hr>

- Mat::ptr() 함수를 사용하여 픽셀 값에 접근하는 방법은 행 단위로 행렬 원소를 참조하는 경우에 유용
- 일반적으로 for 반복문을 이용하여 행렬의 모든 원소를 참조하는 경우, Mat::ptr() 함수를 사용하는 방법이 Mat::at() 함수 사용 방법보다 빠르게 동작
- 다만 행 단위로 연산을 수행하는 것이 아니라 임의 좌표 원소에 빈번하게 접근해야 하는 경우라면 Mat::at() 함수를 사용하는 것이 편리

<hr>

#### MatIterator_ 반복자 사용 방법
- Mat::at() 또는 Mat::ptr() 함수를 사용하여 행렬의 원소를 참조할 경우, 함수 인자로 전달된 값이 행렬의 크기를 벗어나면 에러가 발생
- 그러므로 프로그램 코드를 작성할 때 사용자가 행렬 또는 영상의 크기를 충분히 고려해야 하며, 주의하지 않으면 예기치 않게 프로그램이 종료될 수 있음
- 이러한 단점을 해소하기 위해 OpenCV는 반복자(iterator) 개념을 토입하여 행렬 원소를 참조할 수 있는 방법을 제공
- 즉, Mat 행렬 원소 참조를 위한 반복자 변수를 만들어서 행렬 크기에 상관없이 행렬 전체 원소를 차례대로 참조하는 방식

<hr>

- Mat 클래스와 함께 사용할 수 있는 반복자 클래스 이름은 MatIterator_
- MatIterator_ 클래스는 템플릿으로 정의된 클래스이므로 실제 사용할 때에는 Mat 행렬 타입에 맞는 자료형을 명시하여 사용해야 함
- MatIterator_ 클래스를 사용하는 방식은 C++의 반복자 사용 방법과 유사
- Mat::begin() 함수를 이용하여 행렬의 첫 번째 원소 위치를 얻을 수 있고, Mat::end() 함수를 이용하여 마지막 원소 바로 다음 위치를 얻을 수 있음

<hr>

- 아래는 MatIterator_ 반복자를 사용하여 mat1 행렬의 모든 원소 값을 1씩 증가시키는 예제 코드
  
``` C++
for (MatIterator_<uchar> it = mat1.begin<uchar>(); it != mat1.end<uchar>(); ++it) {
  (*it)++;
}
```

- 위 예제 코드의 for 반복문에서는 MatIterator_<uchar> 타입의 변수 it를 선언하고, mat1.begin<uchar>() 함수의 반환값으로 초기화
- 그리고 it 값이 mat1.end<uchar>()와 같아질 때까지 위치를 증가시키면서, 해당 위치 원소 값을 1씩 증가
- 이때 반복자 변수 it가 가리키는 원소 값을 참조하기 위해 (*it) 형태로 코드를 작성

<hr>

- MatIterator_ 반복자를 사용하면 행렬의 가로 또는 세로 크기에 상관없이 행렬의 모든 원소를 안전하게 방문할 수 있음
- 다만 MatIterator_ 반복자를 사용하는 방법은 동작 속도 면에서 Mat::ptr() 사용 방법보다 느린 편이고, Mat::at() 함수처럼 임의의 위치에 자유롭게 접근할 수 없어서 사용성이 높지 않은 편

<hr>

- 세 가지 행렬 원소 참조 방법을 사용하여 행렬 원소 값을 1씩 증가시키는 예제 코드를 src\ch03_02 프로젝트 파일에 구현 `주석 3-10`

<hr>

### 3.2.6 행렬 정보 참조하기

- Mat 객체에서 가장 자주 참조하는 정보는 행렬 또는 영상의 크기 정보
- Mat::rows 멤버 변수는 행렬의 행 개수를 나타내고, Mat::rows 멤버 변수는 열 개수를 나타냄
- Mat 객체에 영상이 저장되어 있는 경우라면 Mat::rows는 영상의 세로 픽셀 크기이고, Mat::cols는 영상의 가로 픽셀 크기를 나타냄
- 이들 맴버 변수는 모두 public 접근 지시자로 선언되어 있기 때문에 클래스 외부에서도 자유롭게 접근할 수 있음
- 예를 들어 lenna.bmp 레나 영상을 불러와서 영상의 가로 및 세로 크기를 출력하려면 다음과 같이 코드를 작성할 수 있음
  
``` C++
Mat img1 = imread("lanna.bmp");

cout << "Width: " << img1.cols << endl;
cout << "Height: " << img1.rows << endl;
```

- 위 코드에서 img1 영상의 가로 크기를 출력하기 ㅜ이해 img1.cols를 사용하였고, 세로 크기를 출력하기 위해 img1.rows를 사용
- 실제로 lenna.bmp 파일의 레나 영상 크기는 512×512이기 때문에 위 코드를 실행하면 다음과 같은 문자열이 출력

```
Width: 512
Height: 512
```

<hr>

- Mat 클래스의 Mat::data 멤버 변수는 행렬 원소 데이터가 저장되어 있는 메모리 공간의 시작 주소를 가리키는 포인터
- Mat::data 멤버 변수가 가리키는 메모리 주소를 활용하면 행렬 원소를 사용자가 직접 참조할 수 있음
- 그러나 포인터 연산을 잘못하면 에러가 발생할 수 있으므로 행렬 원소 접근을 위해서 Mat::data 변수를 직접 프로그램 코드에서 다루는 것보다는 Mat::at() 또는 Mat::ptr() 등의 함수를 사용하는 것을 권장

<hr>

- Mat::rows와 Mat::cols 멤버 변수에 저장된 크기 정보 외에 다른 행렬 정보는 Mat 클래스에서 제공하는 멤버 함수를 이용하여 참조할 수 있음
- Mat 클래스에서 행렬의 정보 확인을 위해 사용할 수 있는 멤버 함수는 아래와 같음
- 아래 함수들은 모두 const 키워드가 붙어 있으며 Mat 객체 정보를 참조하는 용도로만 사용됨

> ``` C++
> int Mat::channels() const;
> ```
> 행렬의 채널 수를 반환
> ``` C++
> int Mat::depth() const;
> ```
> 행렬의 깊이를 반환 (ex. CV_8U, CV_32F)
> ``` C++
> size_t Mat::elemSize() const;
> ```
> 한 개의 원소가 차지하는 메모리 크기를 바이트 단위로 반환 (CV_32SC3 타입 행렬의 경우 4×3=12를 반환)
> ``` C++
> size_t Mat::elemSize1() const;
> ```
> 하나의 채널에서 한 개의 원소가 차지하는 메모리 크기를 바이트 단위로 반환(CV_32SC3 타입의 경우 4를 반환)
> ``` C++
> bool Mat::empty() const;
> ```
> 비어 있는 행렬이면 true를 반환
> ``` C++
> bool Mat::isContinuous() const;
> ```
> 각 행의 원소가 연속적으로 저장되어 있으면 true를 반환
> ``` C++
> bool Mat::isSubmatrix() const;
> ```
> 행렬이 다른 행렬의 부분 행렬이면 true를 반환
> ``` C++
> Size Mat::size() const;
> ```
> 행렬 크기를 Size 타입으로 반환
> ``` C++
> size_t Mat::total() const;
> ```
> 전체 원소 개수를 반환
> ``` C++
> int Mat::type() const;
> ```
> 행렬의 타입을 반환 (ex. CV_32FC1, CV_8UC3)
  
- 예를 들어 현재 다루고 있는 영상 객체가 그레이스케일 영상인지 혹은 3채널 컬러 영상인지를 확인하려면 Mat::type() 멤버 함수를 이용할 수 있음
  - 일반적으로 그레이스케일 영상은 CV_8UC1 타입을 사용하며, 3채널 컬러 영상은 CV_8UC3 타입을 사용
  - Mat::type() 함수의 반환값이 CV_8UC1이면 그레이스케일 영상으로 간주하고, CV_8UC3이면 3채널 트루컬러 영상이라고 생각할 수 있음
- 위 예제 코드에서 img1에 저장된 레나 영상이 그레이스케일 영상인지 확인하는 문자열을 출력하려면 아래와 같이 코드를 작성
  
``` C++
if (img1.type() == CV_8UC1)
  cout << "img1 is a grayscale image." << endl;
else if (img1.type() == CV_8UC3)
  cout << "img1 is a truecolor image." << endl;
```
  
- 위에서 lenna.bmp 파일로부터 img1 영상을 불러올 때, imread() 함수의 두 번째 인자를 설정하지 않았으므로 img1 영상은 3채널 컬러 영상으로 생성됨
- 그러므로 img1 영상의 타입은 CV_8UC3이고, 앞 예제 코드는 다음 문자열을 출력
  
`img1 is a truecolor image.`
  
<hr>

- Mat 객체에 저장된 행렬 속성 정보가 아니라 행렬 원소 값을 직접 확인하고자할 때 만약 Mat 클래스에 저장된 객체가 영상이라면 imshow() 함수를 이용하여 화면에 표시할 수 있음
- 그러나 Mat 객체에 int, float, double 같은 자료형의 행렬이 저장되어 있는 경우라면 imshow() 함수를 사용하는 것이 적절하지 않음
- 이런 경우에는 C++ 표준 출력 스트림 std::cout으로 Mat 객체에 저장된 행렬 원소를 출력할 수 있음
- OpenCV는 << 연산자 재정의를 이용하여 행렬 원소를 출력하는 기능을 제공

> ``` C++
> static inline
> std::ostream& operator << (std::ostream& out, const Mat& mtx)
> ```
> - out : C++ 표준 출력 스트림 객체
> - mtx : 출력할 행렬
> - 반환값 : C++ 표준 출력 스트림 객체의 참조
  
- << 연산자 왼쪽에는 std::coutㄹ을 적고, << 연산자 오른쪽에는 Mat 객체 변수 이름을 적으면 해당 행렬 원소가 모두 콘솔 창에 출력됨
- 예를 들어 작은 크기의 행렬 원소를 모두 화면에 출력하려면 아래와 같이 코드를 작성할 수 있음
  
``` C++
float data[] = { 2.f, 1.414f, 3.f, 1.732f };
Mat mat1(2, 2, CV_32FC1, data);

std::cout << mat1 << std::endl;
```

- 위 코드에서 mat1은 float 자료형을 사용하는 2×2 행렬이고, 행렬 원소는 data 배열로 구성됨
- 이 행렬을 << 연산자를 이용하여 std::cout 표준 출력 스트림으로 전달하면 콘솔 창에 다음과 같은 형태로 행렬 원소 값이 나타남

```
[2, 1.414;
 3, 1.732]
```

- 즉, << 연산자를 이용하여 C++ 표준 출력 스트림으로 Mat 객체를 내보내면 [] 대괄호 안에 행렬 원소가 행과 열을 구분하여 출력됨
- 각각의 원소는 콤마(,)로 구분되어 나타나고, 각 행은 세미콜론(;)으로 구분됨
- 작은 크기의 행렬뿐만 아니라 큰 영상 객체에 대해서도 << 연산자를 이용하여 픽셀 값을 출력할 수 있지만, 콘솔 창에 너무 많은 숫자가 한꺼번에 나타날 수 있으므로 주의해야 함

<hr>

- 행렬 정보 참조 예제 코드를 src\ch03_02 프로젝트 파일에 구현 `주석 3-11`

<hr>